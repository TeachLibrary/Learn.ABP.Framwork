{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","title":"ABP学习","structure":"mind_right","root":true,"background":"#ffffcc","theme":"jianbihua","children":[{"id":"50450176e3b1","title":"1. ABP总体介绍","parent":"root","children":[{"id":"187d1abbe00e","title":"介绍","children":[{"tags":[{"text":"基础框架和项目模板","color":"#276F86","background":"#d6f0f8"},{"text":"基于DDD思想","color":"#276F86","background":"#d6f0f8"}],"id":"44f3851d1585","title":"ABP是“ASP.NET Boilerplate Project (ASP.NET样板项目)”的简称。","children":[],"parent":"187d1abbe00e","note":"ASP.NET Boilerplate是一个用最佳实践和流行技术开发现代WEB应用程序的新起点，它旨在成为一个通用的WEB应用程序基础框架和项目模板。\n\nASP.NET Boilerplate 基于DDD的经典分层架构思想，实现了众多DDD的概念（但没有实现所有DDD的概念）。"},{"tags":[{"text":"ABP的官方网站","color":"#276F86","background":"#d6f0f8"}],"id":"796ec8b2f4c4","title":"ABP的官方网站","children":[],"parent":"187d1abbe00e","note":"ABP的官方网站：http://www.aspnetboilerplate.com\nABP在Github上的开源项目：https://github.com/aspnetboilerplate"},{"id":"4636e9679a4e","title":"采用的技术","children":[{"id":"470eab3c30e9","title":"服务器端","children":[{"id":"cf9f043dc4d8","title":"ASP.NET MVC 5、Web API 2、C# 5.0<br>DDD领域驱动设计 （Entities、Repositories、Domain Services、Domain Events、Application Services、DTOs等）<br>Castle windsor （依赖注入容器）<br>Entity Framework 6 \\ NHibernate，数据迁移<br>Log4Net（日志记录）<br>AutoMapper（实现Dto类与实体类的双向自动转换）","children":[],"parent":"470eab3c30e9"}],"parent":"4636e9679a4e","icons":[{"text":"&#xe67e","index":"31","color":"rgb(80, 194, 139)","name":"flag"}]},{"id":"3ba6ebd7bde8","title":"客户端","children":[{"id":"104420769e85","title":"Bootstrap<br>Less<br>AngularJs<br>jQuery<br>Modernizr<br>其他JS库: jQuery.validate、jQuery.form、jQuery.blockUI、json2","children":[],"parent":"3ba6ebd7bde8"}],"parent":"4636e9679a4e","icons":[{"text":"&#xe67e","index":"32","color":"rgb(255, 0, 0)","name":"flag"}]},{"id":"8a00238a51ae","title":"ABP框架已实现了以下特性","children":[{"id":"63af45b04527","title":"多语言/本地化支持<br>多租户支持（每个租户的数据自动隔离，业务模块开发者不需要在保存和查询数时写相应代码）<br>软删除支持（继承相应的基类或实现相应接口，会自动实现软删除）<br>统一的异常处理（应用层几乎不需要处理自己写异常处理代码）<br>数据有效性验证（Asp.NET MVC只能做到Action方法的参数验证，ABP实现了Application层方法的参数有效性验证）<br>日志记录（自动记录程序异常）<br>模块化开发（每个模块有独立的EF DbContext，可单独指定数据库）<br>Repository仓储模式（已实现了Entity Framework、NHibernate、MangoDB、内存数据库）<br>Unit Of Work工作单元模式（为应用层和仓储层的方法自动实现数据库事务）<br>EventBus实现领域事件(Domain Events)<br>DLL嵌入资源管理<br>通过Application Services自动创建Web Api层（不需要写ApiController层了）<br>自动创建Javascript 的代理层来更方便使用Web Api<br>封装一些Javascript 函数，更方便地使用ajax、消息框、通知组件、忙状态的遮罩层","children":[],"parent":"8a00238a51ae"},{"id":"dacdf54f38c1","title":"“Zero”的模块，实现了以下功能","children":[{"id":"cc37e12e466b","title":"身份验证与授权管理（通过ASP.NET Identity实现的）<br>用户&amp;角色管理<br>系统设置存取管理（系统级、租户级、用户级，作用范围自动管理）<br>审计日志（自动记录每一次接口的调用者和参数）","children":[],"parent":"dacdf54f38c1"}],"parent":"8a00238a51ae"}],"parent":"4636e9679a4e","icons":[{"text":"&#xe67e","index":"27","color":"rgb(96, 160, 240)","name":"flag"}],"collapsed":false}],"parent":"187d1abbe00e"},{"id":"d40f75fc459e","title":"如何使用","children":[{"id":"da26f471f838","title":"如果需要直接使用ABP组件，可以通过Nuget安装（在VS的Nuget包管理界面搜索ABP）","children":[],"parent":"d40f75fc459e"}],"parent":"187d1abbe00e","icons":[{"text":"&#xe693","index":"46","name":""}]},{"id":"0220c07b4687","title":"适用的场景","children":[{"id":"e39ba73774c7","title":"中小规模WEB应用开发，可直接使用ABP框架。 较大型项目可以在ABP框架的源码基础上进行扩展，以实现分布式架构。","children":[],"parent":"0220c07b4687"},{"id":"5cfd6749db5a","title":"注：处理高并发并不是ABP的强项。需要非常高并发的DDD框架，建议去研究netfocus的ENode。","style":{"font-weight":"bold"},"children":[],"parent":"0220c07b4687","icons":[{"text":"&#xe6c6","index":"10","name":"face"}]}],"parent":"187d1abbe00e"}],"parent":"50450176e3b1","icons":[{"text":"&#xe67e","index":"30","color":"rgb(48, 191, 191)","name":"flag"}]},{"tags":[{"text":"每一层可以用一个或多个程序集来实现","color":"#276F86","background":"#d6f0f8"}],"id":"8fd8a183d76d","title":"多层架构体系","children":[{"id":"e2b292ca7858","title":"基本分层","children":[{"id":"e18ab0297978","title":"<font color=\"#31a8e0\">展现层（Presentation）</font>：提供一个用户界面，实现用户交互操作。<br><font color=\"#ff99ff\">应用层（Application）</font>：进行展现层与领域层之间的协调，协调业务对象来执行特定的应用程序的任务。它不包含业务逻辑。<br><font color=\"#c41230\">领域层（Domain）</font>：包括业务对象和业务规则，这是应用程序的核心层。<br><font color=\"#662c90\">基础设施层（Infrastructure）</font>：提供通用技术来支持更高的层。例如基础设施层的仓储(Repository)可通过ORM来实现数据库交互。","style":{"font-weight":"normal"},"children":[],"parent":"e2b292ca7858"}],"parent":"8fd8a183d76d"},{"tags":[{"text":"根据实际需要","color":"#276F86","background":"#d6f0f8"}],"id":"496fe3346ddb","title":"扩展分层","children":[{"id":"b55c58299f0a","title":"<b><font color=\"#31a8e0\">分布式服务层（Distributed Service）</font></b>：用于公开应用程序接口供远程客户端调用。比如通过ASP.NET Web API或WCF来实现。这些都是常见的以领域为中心的分层体系结构。不同的项目在实现上可能会有细微的差别。","children":[],"parent":"496fe3346ddb"}],"parent":"8fd8a183d76d","note":"根据实际需要，可能会有额外添加的层。"},{"id":"e676b2246a5e","title":"ABP的体系结构","children":[{"id":"7a650c7e04c6","title":"","image":{"w":858,"url":"https://darkcraft.gitbooks.io/abpdocument2chinese/content/Abp/images/1.2.1.png","h":426},"children":[],"parent":"e676b2246a5e"}],"parent":"8fd8a183d76d","note":"","collapsed":true},{"id":"782a34a10658","title":"一个简单的解决方案，大致包含5个项目","children":[{"id":"70b6c145fa37","title":"","image":{"w":291,"url":"https://darkcraft.gitbooks.io/abpdocument2chinese/content/Abp/images/1.2.2.png","h":128},"children":[],"parent":"782a34a10658"}],"parent":"8fd8a183d76d","collapsed":true},{"tags":[{"text":"Castle Windsor","color":"#276F86","background":"#d6f0f8"},{"text":"Log4Net","color":"#276F86","background":"#d6f0f8"}],"id":"bed07e9a5e55","title":"每层的详细说明","children":[{"id":"b8e3cfa27acb","title":"领域层","style":{"font-weight":"bold"},"children":[{"id":"6e841802c7e8","title":"领域层就是业务层，是一个项目的核心，所有业务规则都应该在领域层实现。<br>实体（Entity）： 实体代表业务领域的数据和操作，在实践中，通过用来映射成数据库表。<br>仓储（Repository）： 仓储用来操作数据库进行数据存取。仓储接口在领域层定义，而仓储的实现类应该写在基础设施层。<br>领域服务（Domain service）： 当处理的业务规则跨越两个（及以上）实体时，应该写在领域服务方法里面。<br>领域事件（Domain Event）： 在领域层有些特定情况发生时可以触发领域事件，并且在相应地方捕获并处理它们。<br>工作单元（Unit of Work）： 工作单元是一种设计模式，用于维护一个由已经被修改(如增加、删除和更新等)的业务对象组成的列表。它负责协调这些业务对象的持久化工作及并发问题。","children":[],"parent":"b8e3cfa27acb"}],"parent":"bed07e9a5e55","icons":[{"text":"&#xe693","index":"42","name":""}]},{"id":"8fa648e59a9d","title":"应用层","style":{"font-weight":"bold"},"task":{},"children":[{"id":"97bebbb0567f","title":"应用层提供一些应用服务（Application Services）方法供展现层调用。一个应用服务方法接收一个DTO(数据传输对象)作为输入参数，使用这个输入参数执行特定的领域层操作，并根据需要可返回另一个DTO。在展现层到领域层之间，不应该接收或返回实体(Entity)对象，应该进行DTO映射。 一个应用服务方法通常被认为是一个工作单元（Unit of Work）。用户输入参数的验证工作也应该在应用层实现。ABP提供了一个基础架构让我们很容易地实现输入参数有效性验证。建议使用一种像AutoMapper这样的工具来进行实体与DTO之间的映射。","children":[],"parent":"8fa648e59a9d"}],"parent":"bed07e9a5e55","icons":[{"text":"&#xe693","index":"53","name":""}]},{"id":"0c6328a61d9b","title":"基础设施层","style":{"font-weight":"bold"},"children":[{"id":"4ded6016e593","title":"当在领域层中定义了仓储接口，应该在基础设施层中实现这些接口。可以使用ORM工具，例如EntityFramework或NHibernate。ABP的基类已经提供了对这两种ORM工具的支持。数据库迁移也被用于这一层。","children":[],"parent":"0c6328a61d9b"}],"parent":"bed07e9a5e55","icons":[{"text":"&#xe693","index":"52","color":"rgb(68, 68, 68)","name":""}]},{"tags":[],"id":"ac0ce477bba3","title":"WEB与展现层","style":{"font-weight":"bold"},"children":[{"tags":[{"text":"AngularJs和DurandalJs","color":"#276F86","background":"#d6f0f8"},{"text":"SignalR","color":"#276F86","background":"#d6f0f8"}],"id":"a1ed48335181","title":"Web层使用ASP.NET MVC和Web API来实现。可分别用于多页面应用程序(MPA)和单页面应用程序(SPA)。<br><br>在SPA中，所有资源被一次加载到客户端浏览器中（或者先只加载核心资源，其他资源懒加载），然后通过AJAX调用服务端WebApi接口获取数据，再根据数据生成HTML代码。不会整个页面刷新。","children":[],"parent":"ac0ce477bba3","note":"现在已经有很多SPA的JS框架，例如： AngularJs、 DurandalJs、BackboneJs、EmberJs。 ABP可以使用任何类似的前端框架，但是ABP提供了一些帮助类，让我们更方便地使用AngularJs和DurandalJs。\n在经典的多页面应用（MPA）中，客户端向服务器端发出请求，服务器端代码（ASP.NET MVC控制器）从数据库获得数据，并且使用Razor视图生成HTML。这些被生成后的HTML页面被发送回客户端显示。每显示一个新的页面都会整页刷新。\nSPA和MPA涉及到完全不同的体系结构，也有不同的应用场景。一个管理后台适合用SPA，博客就更适合用MPA，因为它更利于被搜索引擎抓取。\nSignalR是一种从服务器到客户端发送推送通知的完美工具。它能给用户提供丰富的实时的体验。 已经有很多客户端的Javascript框架或库，JQuery是其中最流行的，并且它有成千上万免费的插件。使用Bootstrap可以让我们更轻松地完成写Html和CSS的工作。\nABP也实现了根据Web API接口自动创建 Javascript的代码函数，来简化JS对Web Api的调用。还有把服务器端的菜单、语言、设置等生成到JS端。（但是在我自己的项目中，我是把这些自动生成功能关闭的，因为必要性不是很大，而这些又会比较影响性能）。\nABP会自动处理服务器端返回的异常，并以友好的界面提示用户。"}],"parent":"bed07e9a5e55","icons":[{"text":"&#xe693","index":"48","name":""}],"note":""}],"parent":"8fd8a183d76d","note":"ABP使用Castle Windsor为整个程序框架提供依赖注入的功能。使用Log4Net日志记录组件，提供给其他各层调用以进行日志记录。"}],"parent":"50450176e3b1","icons":[{"text":"&#xe693","index":"46","name":""}],"note":"每一层可以用一个或多个程序集来实现。","collapsed":false},{"id":"761957d3aa98","title":"模块系统","children":[{"id":"caef99721f01","title":"ABP模块系统简介","children":[{"tags":[{"text":"MybolgApplication模块","color":"#276F86","background":"#d6f0f8"}],"id":"64372db0f2a2","title":"ABP框架提供了创建和组装模块的基础，一个模块能够依赖于另一个模块。在通常情况下，一个程序集就可以看成是一个模块。在ABP框架中，一个模块通过一个类来定义，而这个类要继承自AbpModule。&nbsp;<b><font color=\"#f15a23\">对于ABP，我们的建议是为每一个程序集创建一个Module（模块）</font></b>","children":[],"parent":"caef99721f01","note":"Assembly程序集：Assembly是一个用来包含程序的名称，版本号，自我描述，文件关联关系和文件位置等信息的一个集合。最简单的理解就是：一个你自己写的类库生成的dll就可以看做是一个程序集，这个程序集可以包括很多类，类又包括很多方法等。\n下面的例子，我们开发一个可以在多个不同应用中被调用MybolgApplication模块，代码如下：\n    public class MyBlogApplicationModule : AbpModule //定义\n    {\n        public override void Initialize() //初始化\n        {\n            IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());\n            //这行代码的写法基本上是不变的。它的作用是把当前程序集的特定类或接口注册到依赖注入容器中。\n        }\n    }\nABP框架会扫描所有的程序集，并且发现AbpModule类中所有已经导入的类，如果你已经创建了包含多个程序集的应用，。"},{"id":"18b1552e82b8","title":"生命期事件","children":[{"tags":[{"text":"Initialize 初始化","color":"#276F86","background":"#d6f0f8"},{"text":"PostInitialize 提交初始化","color":"#276F86","background":"#d6f0f8"},{"text":"Shutdown 关闭","color":"#276F86","background":"#d6f0f8"}],"id":"538ee48752b2","title":"在一个应用中，ABP框架调用了Module模块的一些指定的方法来进行启动和关闭模块的操作。我们可以重载这些方法来完成我们自己的任务。","children":[],"parent":"18b1552e82b8","note":"ABP框架通过依赖关系的顺序来调用这些方法，假如：模块A依赖于模块B,那么模块B要在模块A之前初始化，模块启动的方法顺序如下：\nPreInitialize-B\nPreInitialize-A\nInitialize-B\nInitialize-A\nPostInitialize-B\nPostInitialize-A\n下面是具体方法的说明：\nPreInitialize\n预初始化：当应用启动后，第一次运行会先调用这个方法。在依赖注入注册之前，你可以在这个方法中指定你需要注入的自定义启动类。举个例子吧：假如你创建了一个自定义的TestAbpSession : IAbpSession,那么请在这个方法中对TestAbpSession进行注册。\nInitialize\n初始化：在这个方法中一般是来进行依赖注入的注册，一般我们通过IocManager.RegisterAssemblyByConvention这个方法来实现。如果你想实现自定义的依赖注入，那么请参考依赖注入的相关文档。\nPostInitialize\n提交初始化：最后一个方法，这个方法用来解析依赖关系。\nShutdown\n关闭：当应用关闭以后，这个方法被调用。"}],"parent":"caef99721f01"}],"parent":"761957d3aa98"}],"parent":"50450176e3b1","icons":[{"text":"&#xe693","index":"47","name":""}]},{"tags":[{"text":"module-zero这个例子代码","color":"rgb(255, 255, 255)","background":"rgb(191, 30, 27)"}],"id":"8c996e163c95","title":"启动配置","children":[{"id":"be5c31e7a531","title":"配置ABP","style":{"background-color":"#f15a23"},"children":[{"tags":[{"text":"code","color":"#276F86","background":"#d6f0f8"},{"text":"不同的模块都可以添加导航","color":"#276F86","background":"#d6f0f8"},{"text":"帮助LINK","color":"#276F86","background":"#d6f0f8"}],"id":"5c8f74726374","title":"配置是通过在自己模块的PreInitialize方法中来实现的","children":[],"parent":"be5c31e7a531","note":"public class SimpleTaskSystemModule : AbpModule\n    {\n        public override void PreInitialize()\n        {\n            //在你的应用中添加语言包，这个是英语和作者的土耳其语。\n            Configuration.Localization.Languages.Add(new LanguageInfo(&quot;en&quot;, &quot;English&quot;, &quot;famfamfam-flag-england&quot;, true));\n            Configuration.Localization.Languages.Add(new LanguageInfo(&quot;tr&quot;, &quot;Türkçe&quot;, &quot;famfamfam-flag-tr&quot;));\n\n            Configuration.Localization.Sources.Add(\n                new XmlLocalizationSource(\n                    &quot;SimpleTaskSystem&quot;,\n                    HttpContext.Current.Server.MapPath(&quot;~/Localization/SimpleTaskSystem&quot;)\n                    )\n                );\n\n            //配置导航和菜单\n            Configuration.Navigation.Providers.Add&lt;SimpleTaskSystemNavigationProvider&gt;();\n        }\n\n        public override void Initialize()\n        {\n            IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());\n        }\n    }\n\n\n和orchard类似，abp框架一开始就被设计成模块化的，不同的模块可以通过abp框架来进行配置。举个例子吧，不同的模块都可以添加导航，通过导航添加菜单项到自己定义的主菜单，具体的细节大家可以参照：+\n\n本地化：http://www.aspnetboilerplate.com/Pages/Documents/Localization\n导航：http://www.aspnetboilerplate.com/Pages/Documents/Navigation"}],"parent":"8c996e163c95"},{"id":"10cc36747b5d","title":"配置模块","children":[{"tags":[{"text":"示例代码","color":"#276F86","background":"#d6f0f8"}],"id":"41fdb4872a3b","title":"和.net框架原生的启动配置相比较，abp有哪些不一样呢？abp框架的模块可以通过IAbpModuleConfigurations接口进行个性化的扩展，这样的话，模块配置更加简单、方便。","style":{"background-color":"#99ff99","border-color":"transparent","font-weight":"bold"},"children":[],"parent":"10cc36747b5d","note":"示例代码如下：\n    using Abp.Web.Configuration;\n\n    public override void PreInitialize() \n    {\n        Configuration.Modules.AbpWeb().SendAllExceptionsToClients = true;\n    }\n在上面这个例子中，我们通过配置AbpWeb模块，发送异常到客户端。当然了，不是每一个模块都需要这种配置，通常情况下我们需要，是当一个模块需要在多个不同的应用中重复使用，我们才进行这样的配置。"}],"parent":"8c996e163c95"},{"id":"af5c6a42cb57","title":"为一个模块创建配置","children":[{"tags":[{"text":"code","color":"#276F86","background":"#d6f0f8"},{"text":"依赖注入","color":"#276F86","background":"#d6f0f8"},{"text":"在IocManager中注册了一个类","color":"#276F86","background":"#d6f0f8"},{"text":"HELPLINK","color":"#276F86","background":"#d6f0f8"}],"id":"4b2cea0899d6","title":"假如我们有一个命名为MyModule的模块，并且这各模块有一些自己的配置。那么我们首先要创建一些类，这些类定义为属性（译者注：属性有自动的get和set访问器。），代表了不同的配置。","children":[{"id":"bcc0dc61624e","title":"译者注： 模块配置是一个静态类，因为我们需要重复使用它。静态方法Mymodule返回的是一个配置接口，参数是ImoduleConfigurations接口。","children":[],"parent":"4b2cea0899d6"},{"tags":[{"text":"code","color":"#276F86","background":"#d6f0f8"}],"id":"5c8ed2e309d0","title":"在某种意义上，MyModule需要这些配置，通过注射MyModuleConfig我们就可以使用这些值。","children":[],"parent":"4b2cea0899d6","note":" public class MyService : ITransientDependency\n    {\n        private readonly MyModuleConfig _configuration;\n\n        public MyService(MyModuleConfig configuration)\n        {\n            _configuration = configuration;\n        }\n\n\n        public void DoIt()\n        {\n            if (_configuration.SampleConfig2 == &quot;test&quot;)\n            {\n                //...\n            }\n        }\n    }"},{"id":"c16d3767a5c8","title":"这意味着，在abp框架的系统中，所有的模块都可以集中配置。","children":[],"parent":"4b2cea0899d6"}],"parent":"af5c6a42cb57","note":"public class MyModuleConfig\n    {\n        public bool SampleConfig1 { get; set; }\n\n        public string SampleConfig2 { get; set; }\n    }\n\n接下来，我们通过依赖注入，注册这个类。IocManager.Register();\n\n译者注： 在IocManager中注册了一个类，换句话说，我们通过IocManager可以得到这个类MyModuleConfig的实例。至于IOC的原理这里就不在详细说了，总之，就是可以得到一个类的实例。\n\nhttps://darkcraft.gitbooks.io/abpdocument2chinese/content/Abp/1.4ABP%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D-%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.html"}],"parent":"8c996e163c95"}],"parent":"50450176e3b1","icons":[{"text":"&#xe693","index":"53","color":"rgb(191, 30, 27)","name":""}],"note":"译者注： 在看这一节的内容之前，建议大家先下载module-zero这个例子代码，这个例子就是一个用户和角色的模块，并且使用的实例。配置在每一个应用中都可能会有，比如你有一个网站，你要获取网站的一些自定义基本参数，比如logo位置，网站名称，上传文件大小等等。模块化的配置方式和我们之前的做法肯定是不同的，大家要注意。之前无非就是一个方法getconfig从对应的表取数据，然后使用。+\n\n"},{"id":"c6086c0d4922","title":"多租户","children":[{"id":"8dfa5ad8d4fc","title":"什么是多租户，多租户一般用来创建SaaS(软件即服务）应用程序（云计算）","style":{"background-color":"#ffe6cc"},"children":[{"id":"ed0154f67a2b","title":"多个部署多个数据库，这实际上并不是多租户","children":[],"parent":"8dfa5ad8d4fc","note":"如果为每个客户（租户）配置一个单独的数据库和应用程序的一个实例，即在单个服务器中部署但提供给多个客户（租户）使用，我们需要确保应用程序的多个实例不会因为系统相同的配置环境而发生冲突。 这种已有的设计方式也不是真正为多租户服务的，它的好处是更容易的创建，但是存在一些安装、使用和维护的问题。"},{"tags":[{"text":"可以算是但有问题","color":"#276F86","background":"#d6f0f8"}],"id":"41e622314746","title":"单个部署多个数据库","children":[],"parent":"8dfa5ad8d4fc","note":"应用这种方式，我们能够仅在服务器上运行应用程序的一个实例。当某个用户登录时，从主数据库中检测此租户的信息并获取对应的数据库信息（连接字符串），然后我们连接到对应的数据库中。\n这样的应用程序也可以算是多租户设计，但在安装、使用和维护上也存在一些问题。"},{"tags":[{"text":"这个是的通过TenantId来过滤","color":"#276F86","background":"#d6f0f8"}],"id":"269407bb5817","title":"单个部署单个数据库","children":[],"parent":"8dfa5ad8d4fc","note":"这是真正的多租户构架，我们只在服务器上部署应用程序的单一实例且只有一个数据库。在各表中使用TenantId来隔离其它租户的信息。\n这样的好处是易于安装和维护，但创建这样的一个应用程序比较困难。因为，需要防止租户读写其它租户的信息。在用户读取数据时候可以添加TenantId过滤器过滤数据，同样，系统会检测用户的写入操作。这是很繁琐的，而且也容易出错。ABP可以帮助我们自动数据过滤。"},{"tags":[{"text":"多租户的构架","color":"#276F86","background":"#d6f0f8"}],"id":"20f096536c5b","title":"ABP中的多租户","children":[{"id":"9e380d8e221f","title":"Host VS 租户","style":{"background-color":"#ff9999"},"children":[{"tags":[],"id":"331ee292fe54","title":"Tenant","children":[{"id":"3d3e7cf08026","title":"A customer which have it's own users, roles, permissions, settings... and uses the application completely isolated from other tenants. A multi-tenant application will have one or more tenants. If this is a CRM application, different tenants have also thier own accounts, contacts, products and orders. So, when we say a 'tenant user', we mean a user owned by a tenant.","children":[],"parent":"331ee292fe54"},{"tags":[{"text":"多租户是一种经济的解决方案","color":"#276F86","background":"#d6f0f8"}],"id":"26bc44646599","title":"多租户是指软件架构支持一个实例服务多个用户（Customer），每一个用户被称之为租户（tenant），软件给予租户可以对系统进行部分<br>定制的能力，如用户界面颜色或业务规则，但是他们不能定制修改软件的代码。<br>","children":[],"parent":"331ee292fe54","note":"多租户是指软件架构支持一个实例服务多个用户（Customer），每一个用户被称之为租户（tenant），软件给予租户可以对系统进行部分\n\n定制的能力，如用户界面颜色或业务规则，但是他们不能定制修改软件的代码。\n\n      由于共享开发和维护成本，都某些用户来说，多租户是一种经济的解决方案。从维护角度来说，多租户系统维护更加简单，相比于每个用户\n\n一个实例的单租户系统，多租户系统提供者在系统变更时仅需更新一次，而单租户则需要针对每个用户进行更新，举个例子吧，操作系统可以视为\n\n单租户系统，电子邮件则是典型的多租户系统（这里只说邮件服务系统，不是客户端），操作系统升级时，每个用户都要执行，而电子邮件的升级\n\n无需用户参与。\n\n     在云计算领域，由于新的服务模型利用了虚拟化和远程访问，多租户的含义已被扩展。例如，软件即服务（SaaS）提供者，利用运行在一个数据\n\n库实例上的应用系统，向多个用户提供Web访问服务。在这个场景下，租户之间的数据是隔离的，并且保证每个用户的数据对其他租户不可见。"}],"parent":"9e380d8e221f","note":"","collapsed":false},{"tags":[{"text":"管理租户的单一实例","color":"#276F86","background":"#d6f0f8"}],"id":"d3566c4e5d95","title":"Host","children":[{"id":"d713b095df50","title":"Host is singleton (there is a single host). The Host is responsible to create and manage tenants. So, a 'host user' is higher level and independent from all tenants and can control they.","children":[],"parent":"d3566c4e5d95"}],"parent":"9e380d8e221f","note":"Host和Tenant都是一种比喻\n","collapsed":true},{"tags":[{"text":"租","color":"#276F86","background":"#d6f0f8"}],"id":"ff75d1ad66ef","title":"多租户与多用户的区别？","children":[{"id":"0f1599162d88","title":"多用户共享的是OS资源，多租户共享的是云上的SaaS资源","children":[],"parent":"ff75d1ad66ef","note":"多用户可以看做在你的屋子里给用户一个床位，让他和其他用户一样能用你的屋子的所有资源，但是可以做基本的权限控制，比如该藏的本子要藏的啊。\n多租户可以看做用户把你的整间屋子租了下来，你可以提供给每个租户相似的基本资源，他也可以针对他自己的需求，添加他自己的资源，而且别人看不到。\n从数据库的角度来看，多用户是所有的用户在同一个数据库里面，登录读写什么的都是同一个逻辑数据库。\n多租户是每个租户有他自己的一个企业或者组织，他以企业或者组织的代表者申请一套专门为他们提供服务的数据库，实现数据隔离和客户个性化定制。\n多租户有三种实现，我只举了极端、易于理解的例子，不深究实现和概念，希望有用。"}],"parent":"9e380d8e221f","note":"多用户：强调的是“用”，比如你是某宝的用户，你使用了它的服务。\n\n多租户：强调的是“租”，一定是有什么资源租给你了。比如你使用阿里云的存储服务，阿里是“租”给你它的存储设备，你是它的租户，别人不会看见你存储的数据，就像你租的房子别人不能翻查一样。当然同时你也是阿里云网站的用户。"}],"parent":"20f096536c5b","icons":[{"text":"&#xe67e","index":"28","color":"rgb(191, 30, 27)","name":"flag"}]},{"tags":[{"text":"IAbpSession","color":"#276F86","background":"#d6f0f8"}],"id":"d361e46a2f55","title":"Session","children":[{"id":"8876bdead548","title":"user can not access to authorized content","children":[],"parent":"d361e46a2f55","note":"If both of UserId and TenantId is null, then current user is not logged in to the system. So, we can not know if it&#39;s a host user or tenant user. In this case, user can not access to authorized content."},{"id":"4e261b536b1a","title":"a host user","children":[],"parent":"d361e46a2f55","note":"If UserId is not null and TenantId is null, then we can know that current user is a host user."},{"id":"f3868b649d5c","title":"a tenant user","children":[],"parent":"d361e46a2f55","note":"If UserId is not null and also TenantId is not null, we can know that current user is a tenant user."},{"tags":[],"id":"d2d1ca80e2ac","title":"user did not login","children":[],"parent":"d361e46a2f55","note":"If UserId is null but TenantId is not null, that means we can know the current tenant, but current request is not authorized (user did not login). See the next section to understand how current tenant is determined."}],"parent":"20f096536c5b","note":"ASP.NET Boilerplate defines IAbpSession interface to obtain current user and tenant ids. This interface is used in multi-tenancy to get current tenant&#39;s id by default. Thus, it can filter data based on current tenant&#39;s id. We can say these rules:"},{"tags":[{"text":"通过实现接口来过滤","color":"#276F86","background":"#d6f0f8"}],"id":"dd114abaa686","title":"数据过滤","children":[{"tags":[{"text":"自动隔离","color":"#276F86","background":"#d6f0f8"}],"id":"ef3adb175a7f","title":"IMustHaveTenant Interface","children":[],"parent":"dd114abaa686","note":"IMustHaveTenant Interface\n\n这个接口通过定义TenantId来区分实体不同的租户。示例：\npublic class Product : Entity, IMustHaveTenant\n{\n    public int TenantId { get; set; }\n\n    public string Name { get; set; }\n\n    //...other properties\n}\n因此，ABP能发现这是一个与租户相关的实体，并自动隔离其它租户的实体。"},{"tags":[{"text":"并不普遍","color":"#276F86","background":"#d6f0f8"},{"text":"小心使用","color":"#276F86","background":"#d6f0f8"}],"id":"a179be7abbd3","title":"IMayHaveTenant interface","children":[],"parent":"dd114abaa686","note":"IMayHaveTenant interface\n\n我们可能需要共享Host和租户中间的实体类型。一个实体可能属于租户或Host,MayHaveTenant接口还定义了TenantId(类似于IMustHaveTenant),但在这种情况下可以为空。一个示例实现\npublic class Role : Entity, IMayHaveTenant\n{\n    public int? TenantId { get; set; }\n\n    public string RoleName { get; set; }\n\n    //...other properties\n}\n我们可以使用相同的角色类存储主机角色和租户的角色。TenantId属性,在这种情况下,如果这是一个主机实体或租户entitiy。null值意味着这是一个Host的实体,一个非空值意味着这实体租户Id是的TenantId。\nIMayHaveTenant并不普遍。例如,一个产品类不能IMayHaveTenant自相关产品实际应用功能,管理租户无关。所以,小心使用IMayHaveTenant接口，因为很难保持代码共享的主机和租户。"},{"id":"724d2d4fef1f","title":"保存实体","children":[],"parent":"dd114abaa686","note":"租户的用户不应该创建/编辑其他租户的实体。ASP。净样板检查它在保存更改数据库相关数据过滤器是否启用。"}],"parent":"20f096536c5b","note":"当我们从数据库检索实体，我们必须添加一个TenantId过滤当前的租户实体。当你实现了接口：IMustHaveTenant或IMayHaveTenant中的一个时，ABP将自动完成数据过滤。"}],"parent":"8dfa5ad8d4fc","note":"ABP提供了一个创建单一部署、单一数据库、多租户的构架。"}],"parent":"c6086c0d4922","note":"维基百科:“软件多租户是指一个软件架构的实例软件运行在一个服务器上，但存在多个租户。租户是一组共享一个公共的用户访问特定权限的软件实例。多租户架构,软件应用程序旨在提供每个租户专用的实例包括数据、配置、用户管理、租户个体功能和非功能属性。多租户与多实例架构,独立的软件实例代表不同的租户”操作"}],"parent":"50450176e3b1"},{"tags":[{"text":"Startup","color":"#276F86","background":"#d6f0f8"},{"text":"OwinStartup","color":"#276F86","background":"#d6f0f8"}],"id":"b021b359f395","title":"集成OWIN","children":[],"parent":"50450176e3b1","note":"集成OWIN\n\n如果在你的项目中你用到了 OWIN ，你只需要Nuget来添加 Abp.Owin到你主项目中(一般来说是 Web 项目) 并且在OWIN Startup调用 UserApp() 的扩展方法，如下所示：\n[assembly: OwinStartup(typeof(Startup))]\npublic class Startup\n{\n    public void Configuration(IAppBuilder app)\n    {\n        app.UseAbp();\n\n        //其它配置...\n    }\n}"}],"collapsed":true},{"id":"a6c5ea8292d3","title":"2.&nbsp;ABP公共结构","children":[{"id":"21cbaab4f3fd","title":"依赖注入","children":[{"id":"2063f3a16d4b","title":"构造函数注入(Constructor injection)","children":[],"parent":"21cbaab4f3fd"},{"tags":[{"text":"NullLogger.Instance","color":"#276F86","background":"#d6f0f8"},{"text":"可选的依赖","color":"#276F86","background":"#d6f0f8"}],"id":"0f90c96d74ac","title":" 属性注入(Property injection)","children":[],"parent":"21cbaab4f3fd","note":"采用构造函数的注入模式是一个完美的提供类的依赖关系的方式。通过这种方式，只有提供了依赖你才能创建类的实例。同时这也是一个强大的方式显式地声明，类需要什么样的依赖才能正确的工作。\n但是，在有些情况下，该类依赖于另一个类，但也可以没有它。这通常是适用于横切关注点(如日志记录)。一个类可以没有工作日志，但它可以写日志如果你提供一个日志对象。在这种情况下，你可以定义依赖为公共属性，而不是让他们放在构造函数。想想，如果我们想在PersonAppService写日志。我们可以重写类如下:\n   public class PersonAppService\n    {\n        public ILogger Logger { get; set; }\n\n        private IPersonRepository _personRepository;\n\n        public PersonAppService(IPersonRepository personRepository)\n        {\n            _personRepository = personRepository;\n            Logger = NullLogger.Instance;\n        }\n\n        public void CreatePerson(string name, int age)\n        {\n            Logger.Debug(&quot;Inserting a new person to database with name = &quot; + name);\n            var person = new Person { Name = name, Age = age };\n            _personRepository.Insert(person);\nNullLogger.Instance 是一个单例对象，实现了ILogger接口，但实际上什么都没做(不写日志。它实现了ILogger实例，且方法体为空)。现在，PersonAppService可以写日志了，如果你为PersonAppService实例设置了Logger，如下面:\nVar personService = new PersonAppService(new PersonRepository());\n    personService.Logger = new Log4NetLogger();\n    personService.CreatePerson(&quot;Yunus Emre&quot;, 19);\n假设Log4NetLogger实现ILogger实例，使得我们可以使用Log4Net库写日志。因此，PersonAppService可以写日志。如果我们不设置Logger，PersonAppService就不写日志。因此，我们可以说PersonAppService ILogger实例是一个可选的依赖。\n几乎所有的依赖注入框架都支持属性注入模式。"},{"tags":[{"text":"Castle Windsor","color":"#276F86","background":"#d6f0f8"}],"id":"4593e28659c8","title":"依赖注入框架","children":[],"parent":"21cbaab4f3fd","note":"有许多依赖注入框架，都可以自动解决依赖关系。他们可以创建所有依赖项(递归地依赖和依赖关系)。所以你只需要依赖注入模式写类和类构造函数&属性，其他的交给DI框架处理！在良好的应用程序中，类甚至独立于DI框架。整个应用程序只会有几行代码或类，显示的与DI框架交互。\nABP的依赖注入基于 Castle Windsor框架。Castle Windsor最成熟的DI框架之一。还有很多这样的框架，如Unity，Ninject，StructureMap，Autofac等等。\n在使用一个依赖注入框架时，首先注册你的接口/类到依赖注入框架中，然后你就可以resolve一个对象。在Castle Windsor，它是这样的：\nvar container = new WindsorContainer();\n\n    container.Register(\n            Component.For&lt;IPersonRepository&gt;().ImplementedBy&lt;PersonRepository&gt;().LifestyleTransient(),\n            Component.For&lt;IPersonAppService&gt;().ImplementedBy&lt;PersonAppService&gt;().LifestyleTransient()\n        );\n\n    var personService = container.Resolve&lt;IPersonAppService&gt;();\n    personService.CreatePerson(&quot;Yunus Emre&quot;, 19);\n我们首先创建了WindsorContainer。然后注册PersonRepository 和 PersonAppService及它们的接口。然后我们要求容器创建一个IPersonAppService实例。它创建PersonAppService对象及其依赖项并返回。在这个简单的示例中，使用DI框架也许不是那么简洁，但想象下，在实际的企业应用程序中你会有很多类和依赖关系。当然，注册的依赖项只在程序启动的某个地方创建一次。\n请注意，我们只是将对象声明为临时对象(transient)。这意味着每当我们创建这些类型的一个对象时，就会创建一个新的实例。有许多不同的生命周期(如Singletion单例模式)。"},{"id":"c4c3ff9ef225","title":" ABP依赖注入的基础结构","children":[{"tags":[{"text":"多种不同的方法来注册","color":"#276F86","background":"#d6f0f8"}],"id":"8f41a60aa94c","title":"注册(Registering)","children":[{"id":"a134b71887b3","title":"常规注册(Conventional registrations)&nbsp;<b>约定</b>","children":[{"tags":[{"text":"自动注册","color":"#276F86","background":"#d6f0f8"},{"text":"Repositories","color":"#276F86","background":"#d6f0f8"},{"text":"Domain Services","color":"#276F86","background":"#d6f0f8"},{"text":"Application Services","color":"#276F86","background":"#d6f0f8"},{"text":"MVC 控制器","color":"#276F86","background":"#d6f0f8"},{"text":"Web API控制器","color":"#276F86","background":"#d6f0f8"}],"id":"2e3bd94a8ebd","title":"按照约定，ABP自动注册所有 Repositories， Domain Services， Application Services， MVC 控制器和Web API控制器","children":[],"parent":"a134b71887b3","note":"按照约定，ABP自动注册所有 Repositories， Domain Services， Application Services， MVC 控制器和Web API控制器。例如，你可能有一个IPersonAppService 接口和实现类PersonAppService：\npublic interface IPersonAppService : IApplicationService\n    {\n        //...\n    }\n\n    public class PersonAppService : IPersonAppService\n    {\n        //...\n    }\nABP会自动注册它，因为它实现IApplicationService接口(它只是一个空的接口)。它会被注册为transient (每次使用都创建实例)。当你注入(使用构造函数注入)IPersonAppService接口成一个类，PersonAppService对象会被自动创建并传递给构造函数。\n注意：命名约定在这里非常重要。例如你可以将名字PersonAppService改为 MyPersonAppService或另一个包含“PersonAppService”后缀的名称，由于IPersonAppService包含这个后缀。但是你可以不遵循PeopleService命名你的服务类。如果你这样做，它将不会为IPersonAppService自动注册(它需要自注册（self-registration）到DI框架，而不是接口)，所以，如果你想要你应该手动注册它。\nABP按照约定注册程序集。所以，你应该告诉ABP按照约定注册你的程序集。这很容易:\n  IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());\nAssembly.GetExecutingAssembly()得到一个对包括此代码的程序集的引用。你可以通过RegisterAssemblyByConvention方法注册其他程序集。这同在你的模块初始化（AbpModule.Initialize()）时完成。请查看ABP的模块系统获得更多信息。\n你可以通过实现IConventionalRegisterer接口和调用IocManager。AddConventionalRegisterer方法编写自己的约定注册类。你应该将它添加到模块的pre-initialize方法中。"}],"parent":"8f41a60aa94c","note":""},{"id":"007230befc3b","title":"帮助接口(Helper interfaces)&nbsp;<b>接口</b>","children":[{"id":"87c4a603d721","title":"你可以注册一个特定的类，不遵循传统的约定制度规则。ABP提供了ITransientDependency和ISingletonDependency接口的快捷方法。","children":[],"parent":"007230befc3b","note":"public interface IPersonManager\n    {\n        //...\n    }\n\n    public class MyPersonManager : IPersonManager, ISingletonDependency\n    {\n        //...\n    }\n以这种方式，你可以很容易地注册MyPersonManager为transient。当需要注入IPersonManager时，MyPersonManager会被使用。注意，依赖被声明为单例。因此，创建的MyPersonManager同一个对象被传递给所有需要的类。只是在第一次使用时创建，那么应用程序的整生命周期使用的是同一实例。"}],"parent":"8f41a60aa94c"},{"id":"57b5948bd6a1","title":"自定义/直接 注册(Custom/Direct registration)&nbsp;<b>手动</b>","children":[{"id":"066a77f564b4","title":"如果之前描述的方法还是不足以应对你的情况，你可以使用Castle Windsor注册类和及依赖项。因此，你将拥有Castle Windsor注册的所有能力。","children":[],"parent":"57b5948bd6a1","note":"可以实现IWindsorInstaller接口进行注册。你可以在应用程序中创建一个实现IWindsorInstaller接口的类：\n    public class MyInstaller : IWindsorInstaller\n    {\n        public void Install(IWindsorContainer container, IConfigurationStore store)\n        {\n            container.Register(Classes.FromThisAssembly().BasedOn&lt;IMySpecialInterface&gt;().LifestylePerThread().WithServiceSelf());\n        }\n    }\nAbp自动发现和执行这个类。最后，你可以通过使用IIocManager.IocContainer属性得到WindsorContainer。有关更多信息，阅读Windsor的文档。"}],"parent":"8f41a60aa94c"}],"parent":"c4c3ff9ef225","note":"在ABP中，有很多种不同的方法来注册你的类到依赖注入系统。大部分时间，常规方法就足够了。"},{"id":"be965f550d8d","title":"解析（Resolving）","children":[],"parent":"c4c3ff9ef225","note":"注册通知IOC(控制反转)容器关于你的类，它们的依赖项和生命周期。在你的应用程序需要使用IOC容器创建对象时，ASP.NET提供了一些方法解决依赖关系。"},{"tags":[{"text":"这是使用DI系统最适当的方式","color":"#276F86","background":"#d6f0f8"}],"id":"20d05f9a4391","title":"构造函数 &amp; 属性注入(Constructor &amp; Property Injection)","children":[],"parent":"c4c3ff9ef225","note":"作为最佳实践，应该使用构造函数和属性注入去获取类的依赖。例子：\n public class PersonAppService\n    {\n        public ILogger Logger { get; set; }\n\n        private IPersonRepository _personRepository;\n\n        public PersonAppService(IPersonRepository personRepository)\n        {\n            _personRepository = personRepository;\n            Logger = NullLogger.Instance;\n        }\n\n        public void CreatePerson(string name， int age)\n        {\n            Logger.Debug(&quot;Inserting a new person to database with name = &quot; + name);\n            var person = new Person { Name = name, Age = age };\n            _personRepository.Insert(person);\n            Logger.Debug(&quot;Successfully inserted!&quot;);\n        }\n    }\nIPersonRepository从构造函数注入，ILogger实例从公共属性注入。这样，你的代码不会体现依赖注入系统。这是使用DI系统最适当的方式。"},{"tags":[{"text":"尽可能避免这种情况","color":"#276F86","background":"#d6f0f8"},{"text":"构造注入IOC","color":"#276F86","background":"#d6f0f8"}],"id":"5c7916d04881","title":"IIocResolver 和 IIocManager接口","children":[],"parent":"c4c3ff9ef225","note":"有时可能需要直接创建所需的依赖项，而不是构造函数和属性注入。（应该尽可能避免这种情况）。Abp提供一些服务使得这样的注入很容易实现。例子：\n  public class MySampleClass : ITransientDependency\n    {\n        private readonly IIocResolver _iocResolver;\n\n        public MySampleClass(IIocResolver iocResolver)\n        {\n            _iocResolver = iocResolver;\n        }\n\n        public void DoIt()\n        {\n            //Resolving， using and releasing manually\n            var personService1 = _iocResolver.Resolve&lt;PersonAppService&gt;();\n            personService1.CreatePerson(new CreatePersonInput { Name = &quot;Yunus&quot;, Surname = &quot;Emre&quot; });\n            _iocResolver.Release(personService1);\n\n            //Resolving and using in a safe way\n            using (var personService2 = _iocResolver.ResolveAsDisposable&lt;PersonAppService&gt;())\n            {\n                personService2.Object.CreatePerson(new CreatePersonInput { Name = &quot;Yunus&quot;, Surname = &quot;Emre&quot; });\n            }\n        }\n    }\nMySampleClass是一个应用程序的示例类。IIcResolver通过构造函数注入，然后用它来创建和释放对象。有几个解决方法的重载可以根据需要使用。Release方法用于释放组件(对象)。如果你是手动创建一个对象，调用Release方法释放对象非常重要。否则，你的应用程序会有内存泄漏问题。为了保证对象被释放，尽可能使用ResolveAsDisposable(就像上面的例子所示)。它会在using代码块结束的时候自动调用Release方法。\n如果你想直接使用IOC容器(Castle Windsor)来处理依赖关系项，可以通过构造函数注入 IIocManager并使用它IIocManager.IocContainer 属性。如果你是在一个静态上下文或不能注入IIocManager，还有最后一个方法，你可以使用单例对象IocManager.Instance，你可以在任何地方获取到，它无处不在。但是，在这种情况下你的代码将变得不容易测试。"}],"parent":"21cbaab4f3fd","note":"在编写应用程序时遵循最佳实践和一些约定，ABP几乎让依赖注入框架使用变得无形。","collapsed":true},{"id":"59b2470e7d5d","title":"附件","children":[{"id":"e78f4efd6309","title":" IShouldInitialize 接口","children":[{"id":"505946514024","title":"有些类在第一次使用前需要初始化。IShouldInitialize有Initialize()方法。如果你实现它，那么你的Initialize()方法自动会被自动调用在创建对象之后(在使用之前)。当然，为了使用这个特性，你应该注入/创建此对象","children":[],"parent":"e78f4efd6309"}],"parent":"59b2470e7d5d","note":"。+\n\n","collapsed":true},{"id":"7006e04b2184","title":"ASP.NET MVC &amp; ASP.NET Web API 集成","children":[],"parent":"59b2470e7d5d","note":"当然，我们必须调用依赖注入系统处理依赖关系图的根对象。在一个ASP.NET MVC应用程序，通常是一个控制器类。我们可以使用构造函数注入模式注入控制器。当一个请求来到我们的应用程序中，控制器和所有依赖项被IOC容器递归创建。所以，谁做了这些？这是被Abp扩展的ASP.NET MVC默认控制器工厂自动完成的。ASP.NET Web API 也是相似的。你不用关心对象的创建和释放。"},{"id":"fd44a0c77703","title":"最后说明（Last notes）","children":[{"id":"e1e6e1cc816a","title":"如自定义注册，注入钩子，拦截器等等","style":{"background-color":"#ff9999"},"children":[],"parent":"fd44a0c77703","icons":[{"text":"&#xe67e","index":"32","color":"rgb(255, 0, 0)","name":"flag"}]}],"parent":"59b2470e7d5d","note":"Abp简化并自动使用依赖注入，只要你遵守规则和使用上面的结构。大多数时候这样就够了。但是如果不能满足你的需求，你可以直接使用Castle Windsor的所有能力来执行任何任务(如自定义注册，注入钩子，拦截器等等)。"}],"parent":"21cbaab4f3fd"}],"parent":"a6c5ea8292d3","icons":[{"text":"&#xe693","index":"53","name":""}],"note":"如果你已经了解依赖注入的概念、构造函数和属性注入模式，你可以跳过这一节。\n维基百科：“依赖注入是一种软件设计模式，指一个或多个依赖（或服务）被注入，或通过引用传递，传入一个依赖对象（或客户端）并成为客户状态的一部分。模式通过自身的行为分离了客户依赖的创建，这允许程序设计是松耦合的，同时遵循依赖倒置和单一职责原则。与服务定位器模式直接进行对比，它允许客户了解他们用来查找依赖的机制。”\n如果不使用依赖注入技术，很难进行依赖管理、模块化开发和应用程序模块化。"},{"id":"5f91284ee5a3","title":"会话管理","children":[{"id":"af03b5645db4","title":"简介","children":[{"tags":[{"text":"IAbpSession接口","color":"#276F86","background":"#d6f0f8"}],"id":"d7fc37843339","title":"如果一个应用程序需要登录，则它必须知道当前用户执行了什么操作。因此ASP.NET在展示层提供了一套自己的SESSION会话对象，而ABP则提供了一个可以在任何地方获取当前用户和租户的IAbpSession接口","children":[],"parent":"af03b5645db4","note":" 注意：关于IAbpSession接口：需要获取会话信息则必须实现IAbpSession接口。虽然你可以用自己的方式去实现它（IAbpSession），但是它在module-zero项目中已经有了完整的实现。"}],"parent":"5f91284ee5a3"},{"id":"e1092e9c5582","title":"注入会话","children":[{"tags":[{"text":"使用属性注入","color":"#276F86","background":"#d6f0f8"},{"text":"NullAbpSession","color":"#276F86","background":"#d6f0f8"},{"text":"默认值来初始化","color":"#276F86","background":"#d6f0f8"},{"text":"不在领域层使用IAbpSession","color":"#276F86","background":"#d6f0f8"}],"id":"91af7d6f0d4a","title":"IAbpSession通常是以属性注入的方式存在于需要它的类中，不需要获取会话信息的类中则不需要它","children":[],"parent":"e1092e9c5582","note":"如果我们使用属性注入方式，我们可以用NullAbpSession.Instance作为默认值来初始化它（IAbpSession），如下所示：\npublic class MyClass : ITransientDependency\n{\n    public IAbpSession AbpSession { get; set; }\n\n    public MyClass()\n    {\n        AbpSession = NullAbpSession.Instance;\n    }\n\n    public void MyMethod()\n    {\n        var currentUserId = AbpSession.UserId;\n        //...\n    }\n}\n由于授权是应用层的任务，因此我们应该在应用层和应用层的上一层使用IAbpSession（我们不在领域层使用IAbpSession是很正常的）。\nApplicationService, AbpController 和 AbpApiController 这3个基类已经注入了AbpSession属性，因此在Application Service的实例方法中，能直接使用AbpSession属性。"}],"parent":"5f91284ee5a3","note":""},{"id":"7fa51640097b","title":"AbpSession定义的一些关键属性","children":[{"id":"1f3c93c239a6","title":"UserId: 当前用户的标识ID，如果没有当前用户则为null.如果需要授权访问则它不可能为空。","children":[],"parent":"7fa51640097b"},{"id":"63eada8f6c1a","title":"TenantId: 当前租户的标识ID，如果没有当前租户则为null。","children":[],"parent":"7fa51640097b"},{"id":"43bffa1d2aa8","title":"MultiTenancySide: 可能是Host或Tenant。","style":{"background-color":"#ff9999"},"children":[],"parent":"7fa51640097b","icons":[{"text":"&#xe67e","index":"28","color":"rgb(191, 30, 27)","name":"flag"}]}],"parent":"5f91284ee5a3","note":"UserId和TenantId是可以为null的。当然也提供了不为空时获取数据的 GetUserId()和GetTenantId() 方法 。当你确定有当前用户时，你可以使用 GetUserId()方法。\n如果当前用户为空，使用该方法则会抛出一个异常。GetTenantId()的使用方式和GetUserId()类似。"}],"parent":"a6c5ea8292d3","icons":[{"text":"&#xe693","index":"48","name":""}]},{"id":"b40661820d57","title":" 缓存管理","children":[{"id":"7fb8bdb52be5","title":"简介","children":[{"id":"0aea089f87a2","title":"ABP提供了一个抽象的缓存基类（CacheBase），并且在内部使用 MemoryCache来实现了这个抽象类的所有功能，当然你也能够用其他的缓存提供器来实现它。（例如：Redis 或者 Memcached）","children":[],"parent":"7fb8bdb52be5"}],"parent":"b40661820d57"},{"id":"8b85247c7491","title":"ICacheMananger","children":[{"tags":[{"text":"示例","color":"#276F86","background":"#d6f0f8"},{"text":"不要构造函数中使用GetCache","color":"#276F86","background":"#d6f0f8"}],"id":"98e1125fedf2","title":"ABP对外提供了一个缓存接口ICacheMananger。我们通过构造函数注入这个接口来获取缓存","children":[],"parent":"8b85247c7491","note":"示例如下：\npublic class TestAppService : ApplicationService\n{\n    private readonly ICacheManager _cacheManager;\n\n    public TestAppService(ICacheManager cacheManager)\n    {\n        _cacheManager = cacheManager;\n    }\n\n    public Item GetItem(int id)\n    {\n        //Try to get from cache\n        return _cacheManager\n                .GetCache(&quot;MyCache&quot;)\n                .Get(id.ToString(), () =&gt; GetFromDatabase(id)) as Item;\n    }\n\n    public Item GetFromDatabase(int id)\n    {\n        //... retrieve item from database\n    }\n}\n在这个示例中，我们注入了 ICacheManager接口，并且获取了一个名称为MyCache的缓存。\n注意：GetCache方法\n千万不要在你的构造函数中使用GetCache方法，如果的你的类是一个瞬时对象（transient）这可能导致你的缓存被dispose掉。"}],"parent":"b40661820d57"},{"tags":[{"text":"方法都有异步版本","color":"#276F86","background":"#d6f0f8"},{"text":"ByKey","color":"#276F86","background":"#d6f0f8"}],"id":"3398504cc5c3","title":" ICache","children":[{"tags":[{"text":"基于名称单例","color":"#276F86","background":"#d6f0f8"}],"id":"a02a32c9ea44","title":"ICacheManager.GetCache方法返回了一个ICache对象","children":[],"parent":"3398504cc5c3","note":"每一个缓存都是基于名称单例存在的。只有首次访问时才会被创建，以后你每次用相同的名称去获取的缓存都是相同的。所以我们可以在不同的类中使用相同的名称来共享相同的缓存。\n在示例代码中，我们简单的使用了ICache.Get方法，它有两个参数：\nkey : 要获取的缓存项的唯一标识符\nfactory：如果根据给定的key获取到的缓存项为空，那么factory将会创建一个标识符为key的缓存，并且返回该缓存\nICache接口还有其它方法，例如：GetOrDefault，Set，Remove和Clear。当然也有这些方法的异步（async）版本。"},{"id":"f0423c2dd81a","title":"ICache.Get","children":[{"id":"c73047973756","title":"key : 要获取的缓存项的唯一标识符","children":[],"parent":"f0423c2dd81a"},{"tags":[{"text":"就是个委托方法","color":"#276F86","background":"#d6f0f8"}],"id":"380efb53e690","title":"factory：如果根据给定的key获取到的缓存项为空，那么factory将会创建一个标识符为key的缓存，并且返回该缓存","children":[],"parent":"f0423c2dd81a"}],"parent":"3398504cc5c3"},{"id":"16e12ab8119f","title":"GetOrDefault","children":[],"parent":"3398504cc5c3"},{"id":"456a31c423aa","title":"Set","children":[],"parent":"3398504cc5c3"},{"id":"d5dedfcbe639","title":"Remove","children":[],"parent":"3398504cc5c3"},{"id":"8196b4c4386e","title":"Clear","children":[],"parent":"3398504cc5c3"}],"parent":"b40661820d57","note":"ICache接口用key（字符串类型）来获取缓存value（object类型）","collapsed":true},{"tags":[{"text":"类型安全的包装","color":"#276F86","background":"#d6f0f8"}],"id":"f93d9387637a","title":"ITypedCache","children":[],"parent":"b40661820d57","note":"ITypedCache为ICahe提供了一个类型安全的包装\n\n为了使类型安全转换（ICache到ITypedCache），我们可以用扩展方法AsTyped，而不需要写其它强制类型转换的代码，如下所示：\nITypedCache&lt;int, Item&gt; myCache = _cacheManager.GetCache(&quot;MyCache&quot;).AsTyped&lt;int, Item&gt;();"},{"id":"56f4cea65519","title":"Configuration","children":[{"tags":[{"text":"模块的PreInitialize方法中","color":"#276F86","background":"#d6f0f8"}],"id":"35c60c6c527e","title":"缓存的过期时间默认是60分钟","children":[],"parent":"56f4cea65519","note":"如果你想改变所有的缓存或者指定的缓存来的默认过期时间，你可以这样做，实现如下：\n//Configuration for all caches\nConfiguration.Caching.ConfigureAll(cache =&gt;\n{\n    cache.DefaultSlidingExpireTime = TimeSpan.FromHours(2);\n});\n\n//Configuration for a specific cache\nConfiguration.Caching.Configure(&quot;MyCache&quot;, cache =&gt;\n{\n    cache.DefaultSlidingExpireTime = TimeSpan.FromHours(8);\n});\n这段代码你应该放在模块（module）的PreInitialize方法中。如上所示：MyCache将会在8小时后过期，而其他的缓存将在2小时后过期。\n这些配置将会在首次创建缓存的时候生效。配置不仅仅局限于DefaultSlidingExpireTime，你可以利用ICache接口中的属性获取方法来自由的配置并且初始化它们。"}],"parent":"b40661820d57"}],"parent":"a6c5ea8292d3","icons":[{"text":"&#xe6d9","index":"19","name":"completion"}]},{"id":"a2e25417728d","title":"日志管理","children":[{"id":"77ee6f177e17","title":"服务器端","children":[{"tags":[{"text":"Castle","color":"#276F86","background":"#d6f0f8"}],"id":"e45e78076799","title":"ABP使用Castle Windsor's logging facility日志记录工具，并且可以使用不同的日志类库，比如：Log4Net, NLog, Serilog... 等等","children":[{"id":"a983071692e7","title":"Castle是针对.NET平台的一个开源项目，从数据访问框架ORM到IOC容器，再到WEB层的MVC框架、AOP，基本包括了整个开发过程中的所有东西。","children":[],"parent":"e45e78076799"}],"parent":"77ee6f177e17","note":"对于所有的日志类库，Castle提供了一个通用的接口来实现，我们可以很方便的处理各种特殊的日志库，而且当业务需要的时候，很容易替换日志组件。\n 译者注：Castle是什么?Castle是针对.NET平台的一个开源项目，从数据访问框架ORM到IOC容器，再到WEB层的MVC框架、AOP，基本包括了整个开发过程中的所有东西。ASP.NET Boilerplate的ioc容器就是通过Castle实现的。\nLog4Net是asp.net下面最流行的一个日志库组件， ASP.NET Boilerplate 模板也使用了Log4Net日志库组件，但是呢，我们这里仅仅通过一行关键代码就实现Log4Net 的依赖注入（具体说明在下面的配置文件），所以，如果你想替换成自己的日志组件，也很容易。","collapsed":true}],"parent":"a2e25417728d"},{"id":"3e22e2e27a53","title":"获取日志记录器(logger)","children":[{"id":"80c2bcea8136","title":"不管你选择哪一个日志库组件，通过代码来进行日志记录都是一样的","children":[],"parent":"3e22e2e27a53","note":"（这里吐槽， Castle&#39;s 通用 ILogger 接口实在太牛逼了）。\n下面进入正题：(注:下面的代码是abp框架的Castle.Core源码分析以及实现)\n首先呢，我们要先处理日志记录器对象logger， ASP.NET Boilerplate框架使用了dependency injection依赖注入技术,我们可以很方便的使用依赖注入生成日志记录器对象logger。\n接下来我们看一下 ASP.NET Boilerplate是怎么实现日志记录功能的吧：\nusing Castle.Core.Logging; //1: 导入日志的命名空间，Castle.Core.Logging\n\npublic class TaskAppService : ITaskAppService\n{ \n   //2:通过依赖注入获取日志记录器对象。\n   这里先定义了一个ILogger类型的public属性Logger，这个对象就是我们用来记录日志的对象。在创建了TaskAppService对象（就是我们应用中定义的任务）以后，通过属性注入的方式来实现。\n   public ILogger Logger { get; set; }\n\n   public TaskAppService()\n   { \n      //3: 如果没有日志记录器，将日志记录器返回一个空的实例，不写日志。这是依赖注入的最佳实现方式，\n      //   如果你不定义这个空的日志记录器，当我们获取对象引用并且实例化的时候，就会产生异常。\n      //   这么做，保证了对象不为空。所以，换句话说，不设置日志记录器，就不记录日志，返回一个null的对象。\n      //   NullLogger对象实际上什么都木有，空的。这么做，才能保证我们定义的类在实例化时正常运作。\n      Logger = NullLogger.Instance;\n   }\n\n   public void CreateTask(CreateTaskInput input) \n   {\n      //4: 写入日志\n     Logger.Info(&quot;Creating a new task with description: &quot; + input.Description);\n\n     //TODO: save task to database... \n   } \n}\n写入日志以后，我们可以查看日志文件，就像下面的格式：\nINFO 2014-07-13 13:40:23,360 [8] SimpleTaskSystem.Tasks.TaskAppService - Creating a new task with desc"}],"parent":"a2e25417728d"},{"tags":[{"text":"Controller中已定义过了","color":"#276F86","background":"#d6f0f8"}],"id":"e4822978a234","title":"通过基类使用日志记录(Logger)","children":[{"tags":[{"text":"Log4Net的配置","color":"#276F86","background":"#d6f0f8"},{"text":"Gobal中重新配置一下组件即可","color":"#276F86","background":"#d6f0f8"}],"id":"5d4677275579","title":"配置(Configuration)","children":[],"parent":"e4822978a234","note":"如果你在官网上通过ASP.NET Boilerplate templates 来生成了你的工程，Log4Net的所有配置都自动生成了。\n默认的配置格式如下：\nLog level: 日志记录等级，有DEBUG, INFO, WARN, ERROR or FATAL5个。\nDate and time: 日志记录时间。\nThread number: 每行日志写时候的线程号。\nLogger name: 日志记录器的名字，通常情况就是类名称。\nLog text: 你写入的日志内容。\n配置文件：log4net.config 一般都在项目的web目录下面。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;\n&lt;log4net&gt;\n  &lt;appender name=&quot;RollingFileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot; &gt;\n    &lt;file value=&quot;Logs/Logs.txt&quot; /&gt;\n    &lt;appendToFile value=&quot;true&quot; /&gt;\n    &lt;rollingStyle value=&quot;Size&quot; /&gt;\n    &lt;maxSizeRollBackups value=&quot;10&quot; /&gt;\n    &lt;maximumFileSize value=&quot;10000KB&quot; /&gt;\n    &lt;staticLogFileName value=&quot;true&quot; /&gt;\n    &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;\n        &lt;conversionPattern value=&quot;%-5level %date [%-5.5thread] %-40.40logger - %message%newline&quot; /&gt;\n    &lt;/layout&gt;\n  &lt;/appender&gt;\n  &lt;root&gt;\n    &lt;appender-ref ref=&quot;RollingFileAppender&quot; /&gt;\n    &lt;level value=&quot;DEBUG&quot; /&gt;\n  &lt;/root&gt;\n  &lt;logger name=&quot;NHibernate&quot;&gt;\n    &lt;level value=&quot;WARN&quot; /&gt;\n  &lt;/logger&gt;\n&lt;/log4net&gt;\nLog4Net是一个非常强大和易用的日志库组件，你可以写各种日志，比如写到txt文件，写入到数据库等等。你能设置最小的日志等级，就像上面这个针对NHibernate的配置。不同的记录器写不同的日志，等等。\n具体的用法大家可以参照：http://logging.apache.org/log4net/release/config-examples.html\n最后，在工程的Global.asax 文件中，来定义Log4Net的配置文件：\npublic class MvcApplication : AbpWebApplication\n{\n    protected override void Application_Start(object sender, EventArgs e)\n    {\n        IocManager.Instance.IocContainer.AddFacility&lt;LoggingFacility&gt;(f =&gt; f.UseLog4Net().WithConfig(&quot;log4net.config&quot;));\n        base.Application_Start(sender, e);\n    }\n}\n几行代码就调用了Log4Net这个日志记录组件，工程中的Log4Net库是在 nuget package包中的，你也可以换成其他日志组件库，但是代码不用做任何改变。因为，我们的框架是通过依赖注入实现日志记录器的。+\n\n"}],"parent":"a2e25417728d","note":"ABP提供了MVC Controllers、Web API Controllers和Application service classes的基类（自己定义的控制器和应用服务，都必须要继承ABP的基类，换句话说，当你自定义的Web API controllers、mvc controllers，Application service classes都继承了ABP框架对应的基类，你就可以直接使用日志记录器）。\npublic class HomeController : SimpleTaskSystemControllerBase  \n{ \n   public ActionResult Index() \n   { \n      Logger.Debug(&quot;A sample log message...&quot;); \n      return View(); \n   } \n}\n说明：SimpleTaskSystemControllerBase这个基类控制器是我们自己定义的基类控制器，他必须继承自 AbpController。\n这样实现，日志记录器才能正常工作。当然了，你也可以实现自己的基类，这样的话你也可以不使用依赖注入了。"},{"id":"5a3eea1abc20","title":"客户端","children":[{"id":"14306edb1952","title":"在客户端，ABP有对应的 javascript 日志API","children":[],"parent":"5a3eea1abc20","note":"最后，更厉害的是，你还可以在客户端调用日志记录器。在客户端，ABP有对应的 javascript 日志API，这意味着你可以记录下来浏览器的日志，实现代码如下：\nabp.log.warn(&#39;a sample log message...&#39;);\n注意：客户端javascript的api，这里要说明的是，你可以使用console.log在客户端输出日志，但是这个API 不一定支持所有的浏览器，还有可能导致你的脚本出现异常，你可以使用我们的api，我们的是安全的，你甚至可以重载或者扩展这些api。\n abp.log.debug(&#39;...&#39;);\n abp.log.info(&#39;...&#39;);\n abp.log.warn(&#39;...&#39;);\n abp.log.error(&#39;...&#39;);\n abp.log.fatal(&#39;...&#39;);"}],"parent":"a2e25417728d"}],"parent":"a6c5ea8292d3","icons":[{"text":"&#xe693","index":"40","name":""}]},{"id":"bc6605b66b54","title":" 设置管理","children":[{"tags":[{"text":"服务端或者客户端设置","color":"#276F86","background":"#d6f0f8"},{"text":"通常是存储在数据","color":"#276F86","background":"#d6f0f8"},{"text":"ISettingStore接口","color":"#276F86","background":"#d6f0f8"}],"id":"df012ad81aff","title":"简介","children":[],"parent":"bc6605b66b54","note":"每个应用程序需要存储一些设置并在应用程序的某个地方使用这些设置。ABP框架提供强大的基础架构，我们可以在服务端或者客户端设置，来存储/获取应用程序、 租户和用户级别的配置。\n设置通常是存储在数据库（或另一个来源）中，用名称-值（name-value）字符串对应的结构来表示。我们可以把非字符串值转换成字符串值来存储。\n 注意：关于ISettingStore接口:为了使用设置管理必须实现 ISettingStore 接口。你可以用自己的方式实现它，在module-zero项目中有完整的实现可以参考。\n"},{"tags":[{"text":"继承自SettingProvider","color":"#276F86","background":"#d6f0f8"}],"id":"cc8784776a6d","title":"定义设置","children":[{"id":"44371360daa1","title":"SettingDefinition ","children":[{"id":"d58e1bbfd7d1","title":"Name (必填):必须具有全系统唯一的名称。比较好的办法是定义字符串常量来设置Name。","children":[],"parent":"44371360daa1"},{"id":"73744009d013","title":"Default value: 设置一个默认值。此值可以是null 或空字符串。","children":[],"parent":"44371360daa1"},{"id":"16882959c5cd","title":"Scopes: 定义设置的范围 (见下文)。","children":[],"parent":"44371360daa1"},{"id":"17e4eb3c01df","title":"Display name: 一个可本地化的字符串，用于以后在UI中显示设置的名称。","children":[],"parent":"44371360daa1"},{"id":"5b2f2dbf636b","title":"Description: 一个可本地化的字符串，用于以后在UI中显示设置的描述。","children":[],"parent":"44371360daa1"},{"id":"e8587e9e765d","title":"Group: 可用于设置组。这仅仅是UI使用，不用于设置管理。","children":[],"parent":"44371360daa1"},{"id":"32347dc62713","title":"IsVisibleToClients: 设置为 true 将使设置在客户端可用。","children":[],"parent":"44371360daa1"}],"parent":"cc8784776a6d"},{"id":"487b7dc2711f","title":"Configuration.Settings.Providers.Add()","children":[],"parent":"cc8784776a6d","note":"设置提供程序会自动注册依赖注入。所以，设置提供程序可以注入任何依赖项 (如存储库) 来生成设置定义的一些其它来源。"}],"parent":"bc6605b66b54","note":"使用设置之前必须要先定义。ABP框架是模块化设计，所以不同的模块可以有不同的设置。为了定义模块自己的设置，每个模块都应该创建继承自SettingProvider 的派生类。设置提供程序示例如下所示：\npublic class MySettingProvider : SettingProvider\n{\n    public override IEnumerable&lt;SettingDefinition&gt; GetSettingDefinitions(SettingDefinitionProviderContext context)\n    {\n        return new[]\n                {\n                    new SettingDefinition(\n                        &quot;SmtpServerAddress&quot;,\n                        &quot;127.0.0.1&quot;\n                        ),\n\n                    new SettingDefinition(\n                        &quot;PassiveUsersCanNotLogin&quot;,\n                        &quot;true&quot;,\n                        scopes: SettingScopes.Application | SettingScopes.Tenant\n                        ),\n\n                    new SettingDefinition(\n                        &quot;SiteColorPreference&quot;,\n                        &quot;red&quot;,\n                        scopes: SettingScopes.User,\n                        isVisibleToClients: true\n                        )\n                };\n    }\n}\nGetSettingDefinitions 方法返回 SettingDefinition 对象。SettingDefinition 类的构造函数中有如下参数：\n\n在创建设置提供程序(SettingProvider)之后，我们应该在预初始化(PreIntialize)方法中注册我们的模块:\nConfiguration.Settings.Providers.Add();设置提供程序会自动注册依赖注入。所以，设置提供程序可以注入任何依赖项 (如存储库) 来生成设置定义的一些其它来源。"},{"tags":[{"text":"设置范围是分层的","color":"#276F86","background":"#d6f0f8"},{"text":"Application会覆盖前面的","color":"#276F86","background":"#d6f0f8"}],"id":"62c63d9f9f99","title":"设置范围","children":[{"id":"661925e04eed","title":"Application：应用程序范围设置用于用户/租户独立的设置。例如，我们可以定义一个名为\"SmtpServerAddress\"的设置，当发送电子邮件时，获取服务器的 IP 地址。如果此设置有一个单一的值 (不基于用户改变)，那么我们可以定义它为应用程序范围。","children":[],"parent":"62c63d9f9f99"},{"id":"a97be3402f93","title":"Tenant：如果应用程序是多租户的，我们可以定义特定于租户的设置。","children":[],"parent":"62c63d9f9f99"},{"id":"c9014579f6c8","title":"User：我们可以使用的用户范围的设置来为每个用户存储/获取设置的值。","children":[],"parent":"62c63d9f9f99"}],"parent":"bc6605b66b54","note":"SettingScopes 枚举具有Flags属性，所以我们可以定义一个具有多个作用域的设置。\n设置范围是分层的。例如，如果我们定义设置范围为&quot;Application | Tenant | User&quot;并尝试获取当前设置的值;\n我们获取特定用户的值，如果它定义了 (重写) User;如果没有定义User，我们获取特定的租户值，如果它定义了 (重写) Tenant。如果也没有，我们获取应用的值，如果它定义了Application。如果还是没有，我们得到的默认值。\n默认值可以是 null 或空字符串。如果可以，建议为设置提供一个默认值。"},{"tags":[{"text":"服务器","color":"#276F86","background":"#d6f0f8"},{"text":"客户端","color":"#276F86","background":"#d6f0f8"}],"id":"370d4ba02017","title":"获取设置值","children":[{"tags":[{"text":"ISettingManager","color":"#276F86","background":"#d6f0f8"},{"text":"注入使用","color":"#276F86","background":"#d6f0f8"},{"text":"SettingManager的属性","color":"#276F86","background":"#d6f0f8"}],"id":"3fbee99bd74c","title":"服务器端（Server side）","children":[],"parent":"370d4ba02017","note":"ISettingManager 用于执行设置操作。我们可以在应用程序中任何地方注入和使用它。ISettingManager 定义了很多获取设置值方法。\n最常用的方法是 GetSettingValue (或GetSettingValueAsync 为异步调用)。它将返回当前设置的基于默认值、 应用程序、 租户和用户设置范围的值(如设置范围之前的一段中所述)。例子:\n//Getting a boolean value (async call)\nvar value1 = await SettingManager.GetSettingValueAsync&lt;bool&gt;(&quot;PassiveUsersCanNotLogin&quot;);\n//Getting a string value (sync call)\nvar value2 = SettingManager.GetSettingValue(&quot;SmtpServerAddress&quot;);\nGetSettingValue 有泛型和异步版本，如上所示。也有方法来获取特定的租户或用户的设置值或所有设置值的列表。\n由于ISettingManager使用广泛，一些特定的基类 (如 ApplicationService、 DomainService 和 AbpController) 有一个名为 SettingManager的属性。如果我们从这些类继承，就无需显式地注入它。"},{"tags":[{"text":"更改无通知","color":"#276F86","background":"#d6f0f8"},{"text":"要重新刷新","color":"#276F86","background":"#d6f0f8"}],"id":"726f4db54944","title":"客户端(Client side)","children":[{"id":"f5574d424e06","title":"abp.setting.get(\"SiteColorPreference\");","children":[],"parent":"726f4db54944"}],"parent":"370d4ba02017","note":"如果定义设置时将 IsVisibleToClients 设置为 true，就可以在客户端使用 javascript得到它的当前值。abp.setting 命名空间定义所需的函数和对象。示例:\nvar currentColor = abp.setting.get(&quot;SiteColorPreference&quot;);\n也有 getInt 和 getBoolean 这样的方法。你可以使用 abp.setting.values 对象获取所有值。请注意，如果你在服务器端更改设置，客户端不会知道这种变化，除非刷新页面或者以某种方式重新加载页面或者通过代码手动更新。"},{"id":"223bcb5f6fe6","title":"更改设置","children":[{"id":"11a642996c75","title":"ISettingManager定义了ChangeSettingForApplicationAsync，ChangeSettingForTenantAsync 和 ChangeSettingForUserAsync 方法（以及同步版本）来更改应用程序，租户和用户分别的设置。","children":[],"parent":"223bcb5f6fe6"}],"parent":"370d4ba02017"},{"id":"0dca85ebb0a7","title":"关于缓存","children":[{"id":"0c90de595b22","title":"缓存在服务器端设置管理，所以，我们不应直接使用存储库或数据库更新语句改变设置的值。","children":[],"parent":"0dca85ebb0a7"}],"parent":"370d4ba02017"}],"parent":"bc6605b66b54","note":"定义设置后，我们可以在服务器和客户端获取到它的当前值。"}],"parent":"a6c5ea8292d3","icons":[{"text":"&#xe693","index":"53","name":""}]}],"parent":"root","collapsed":true},{"id":"f5f9711dd7b1","title":"3 ABP领域层","children":[{"id":"416360d2b8d8","title":"实体","task":{},"children":[{"tags":[{"text":"DDD","color":"#276F86","background":"#d6f0f8"}],"id":"fea06bc4157c","title":"实体是 DDD（领域驱动设计）的核心概念之一<br>","style":{"background-color":"#f15a23"},"children":[],"parent":"416360d2b8d8","note":"实体是 DDD（领域驱动设计）的核心概念之一。Eric Evans 是这样描述的“很多对象不是通过它们的属性定义的，而是通过一连串的连续性事件和标识定义的”（引用领域驱动设计一书）。\n译者注：对象不是通过它们的属性来下根本性的定义，而应该是通过它的线性连续性和标识性定义的。所以，实体是具有唯一标识的ID且存储在数据库中。实体通常被映射成数据库中的一个表。"},{"id":"c23ae4b07098","title":"实体类","children":[{"tags":[{"text":"Entity有Id","color":"#276F86","background":"#d6f0f8"},{"text":"可以更改其类型","color":"#276F86","background":"#d6f0f8"},{"text":"不可更改其名称","color":"#276F86","background":"#d6f0f8"}],"id":"7673fc85e0a9","title":"在 ABP 中，实体继承自 Entity 类","children":[],"parent":"c23ae4b07098","note":"请看下面示例：\npublic class Person : Entity \n{     \n    public virtual string Name { get; set; } \n    public virtual DateTime CreationTime { get; set; } \n    public Task() \n    { \n        CreationTime = DateTime.Now; \n    } \n}\n我们定义一个实体类Person，并且为它定义两个属性。父类Entity具有主键属性Id。所有继承Entity类的子类都将具有主键为Id的属性。\nId数据类型可以被更改。默认是 int类型。如果你想给 Id 定义其它类型，你应该像下面示例一样来指定 Id 的类型。\npublic class Person : Entity&lt;long&gt; \n{     \n    public virtual string Name { get; set; } \n    public virtual DateTime CreationTime { get; set; } \n    public Task() \n    { \n        CreationTime = DateTime.Now; \n    } \n}\n你可以设置为 string，Guid 或者其它你想要的数据类型。 实体类重写了 equality (==) 操作符用来判断两个实体对象是否相等（主要是判断两个实体的 Id主键 是否相等）。 还定义了一个 IsTransient()方法来检测当前 Id 的值是否与指定的类型的缺省值相等。"}],"parent":"416360d2b8d8"},{"tags":[{"text":"实现接口实现功能","color":"#276F86","background":"#d6f0f8"},{"text":"IFullAudited","color":"#276F86","background":"#d6f0f8"}],"id":"f344ba30e915","title":"接口约定","children":[{"tags":[{"text":"IHasCreationTime","color":"#276F86","background":"#d6f0f8"},{"text":"IAudited","color":"#276F86","background":"#d6f0f8"}],"id":"e2a6cfcdc071","title":"1. 审计（Auditing）","children":[],"parent":"f344ba30e915","note":"实现 IHasCreationTime 接口。当该实体被插入到数据库时， ABP 会自动设置该属性的值为当前时间\n\npublic interface IHasCreationTime \n{ \n    DateTime CreationTime { get; set; } \n}\n我们可以给Person 类实现 IHasCreationTime 接口：\npublic class Person : Entity&lt;long&gt;, IHasCreationTime \n{     \n    public virtual string Name { get; set; } \n    public virtual DateTime CreationTime { get; set; } \n    public Task() \n    { \n        CreationTime = DateTime.Now; \n    } \n}\nICreationAudited 扩展自 IHasCreationTime 并且该接口具有属性 CreatorUserId ：\npublic interface ICreationAudited : IHasCreationTime \n{     \n    long? CreatorUserId { get; set; } \n}\n当保存一个新的实体时，ABP 会自动设置 CreatorUserId 的属性值为当前用户的 Id 。 你可以很容易的实现 ICreationAudited 接口，通过派生自实体类 CreationAuditedEntity。它有一个实现不同 Id主键 数据类型的泛型版本。\n下面是一个为实现类似修改功能的接口\npublic interface IModificationAudited \n{ \n    DateTime? LastModificationTime { get; set; }     \n    long? LastModifierUserId { get; set; } \n}\n当更新一个实体时，APB 会自动设置这些属性的值。你只需要在你的实体类里面实现这些属性。 如果你想实现所有的审计属性，你可以直接扩展 IAudited 接口；示例如下：\npublic interface IAudited : ICreationAudited, IModificationAudited \n{ \n\n}\n作为一个快速开发方式，你可以直接派生自 AuditedEntity 类，不需要再去实现 IAudited 接口，AuditedEntity 类有一个实现不同 ID 数据类型的泛型版本(默认是 int)。"},{"tags":[{"text":"ISoftDelete","color":"#276F86","background":"#d6f0f8"},{"text":"删除标识","color":"#276F86","background":"#d6f0f8"},{"text":"Db中仍在","color":"#276F86","background":"#d6f0f8"},{"text":"不可从ABP中获取","color":"#276F86","background":"#d6f0f8"}],"id":"b2cc45baabd9","title":"2. 软删除(Soft delete)","children":[{"id":"415531533963","title":"所有的审计接口和类都有一个泛型模板","style":{"background-color":"#f384ae"},"children":[],"parent":"b2cc45baabd9","note":"为了导航定义属性到你的 User 实体，所有的审计接口和类都有一个泛型模板（例如： ICreationAudited和FullAuditedEntity），这里的TUser指的进行创建，修改和删除的用户的实体类的类型， 详细请看源代码（Abp.Domain.Entities.Auditing 空间下的FullAuditedEntity类），TprimaryKey 指的是Entity基类Id 类型，默认是int。"}],"parent":"f344ba30e915","note":"软删除是一个通用的模式，它标记一个实体已经被删除了，而不是实际从数据库中删除记录。 例如：你可能不想从数据库中硬删除一条用户记录，因为它被许多其它的表所关联。 为了实现软删除的目的我们可以实现该接口 ISoftDelete：\npublic interface ISoftDelete\n{     \n    bool IsDeleted { get; set; } \n}\nABP 实现了开箱即用的软删除模式。当一个实现了软删除的实体正在被删除， ABP 会察觉到这个动作，并且阻止其真正删除，设置 IsDeleted 属性值为 true 并且更新数据库中的实体。也就是说，被软删除的记录不可以从数据库中检索出，ABP 会为我们自动过滤软删除的记录。（例如：Select 查询，这里指通过 ABP 查询，不是通过数据库中的查询分析器查询。）\n如果你用了软删除，你有可能也想实现这个功能，就是记录谁删除了这个实体。要实现该功能你可以实现 IDeletionAudited 接口，请看下面示例：\npublic interface IDeletionAudited : ISoftDelete \n{     \n    long? DeleterUserId { get; set; } \n    DateTime? DeletionTime { get; set; } \n}\n正如你所看到的 IDeletionAudited 扩展自 ISoftDelete 接口。当一个实体被删除的时候 ABP 会自动的为这些属性设置值。 如果你想为实体类扩展所有的审计接口（例如：创建（creation），修改（modification）和删除（deletion）），你可以直接实现 IFullAudited 接口，因为该接口已经继承了这些接口。 请看下面示例：\npublic interface IFullAudited : IAudited, IDeletionAudited \n{ \n\n}\n作为一个快速开发方式，你可以直接从 FullAuditedEntity 类派生你的实体类，因为该类已经实现了 IFullAudited 接口。\n"},{"tags":[{"text":"可以被获取","color":"#276F86","background":"#d6f0f8"}],"id":"afa0ba971c48","title":"3. 激活状态/闲置状态(Active/Passive)","children":[],"parent":"f344ba30e915","note":"有些实体需要被标记为激活状态或者闲置状态。那么你可以为实体采取 active/passive 状态的方式来实现。 基于这个原因而创建的实体，你可以扩展IPassivable 接口来实现该功能。该接口定义了 IsActive 的属性。\n如果你首次创建的实体被标记为激活状态，你可以在构造函数设置 IsActive 属性值为 true。这不同于软删除（IsDeleted）。 如果实体被软删除，它不能从数据库中被检索到（ABP 已经过滤了软删除记录）。但是对于激活状态/闲置状态的实体，这完全取决于你怎样去获取这些被标记了的实体。"}],"parent":"416360d2b8d8","note":"在多数应用程序中，实体一般都具有像 CreationTime 的属性，用来指示该实体是什么时候被创建的。APB 提供了一些有用的接口来实现这些类似的功能。（通俗的说只要实现指定的接口就能实现指定的功能）。"},{"tags":[{"text":"可以自已从这个实现","color":"#276F86","background":"#d6f0f8"},{"text":"不建议","color":"#276F86","background":"#d6f0f8"}],"id":"88757f932ea1","title":"IEntity 接口","children":[],"parent":"416360d2b8d8","note":"事实上 Entity 实现了 IEntity 接口（ Entity 实现了 IEntity接口）。如果你不想从 Entity 类派生，你能直接的实现这些接口。 其他实体类也可以实现相应的接口。但是不建议你用这种方式。除非你有一个很好的理由不从 Entity 类派生。"}],"parent":"f5f9711dd7b1","icons":[{"index":"52","name":""}]},{"id":"56a2f0d77d4e","title":"仓储","children":[{"id":"88f66c28c5a9","title":"仓储定义：“在领域层和数据映射层的中介,使用类似集合的接口来存取领域对象”(Martin Fowler)。\n<br>实际上，仓储被用于领域对象在数据库上的操作(实体Entity和值对象Value types)。一般来说,我们针对不同的实体(或聚合根Aggregate Root)会创建相对应的仓储。","children":[],"parent":"56a2f0d77d4e"},{"tags":[{"text":"继承自IRepository","color":"#276F86","background":"#d6f0f8"},{"text":"如IPersonRepository","color":"#276F86","background":"#d6f0f8"}],"id":"0444fd4de8be","title":"IRepository接口","children":[{"tags":[{"text":"常用方法","color":"#276F86","background":"#d6f0f8"}],"id":"cdccbe7d26a5","title":"1. 查询(Query)","children":[{"tags":[{"text":"Lambda表达式","color":"#276F86","background":"#d6f0f8"}],"id":"db8b616090c7","title":"取得单一实体(Getting single entity)","children":[{"id":"139e17394d58","title":"Get不到实体时抛异常","children":[],"parent":"db8b616090c7"},{"id":"104687a66260","title":"Single找到的不是唯一一个时抛异常","children":[],"parent":"db8b616090c7"},{"id":"4d1937b685c6","title":"FirstOrDefault，没有为null，不止一个时返回第一个","children":[],"parent":"db8b616090c7"},{"id":"e196d98eb61e","title":"Load方法延迟执行，性能要求时执行","style":{"background-color":"#f15a23"},"children":[],"parent":"db8b616090c7","icons":[{"index":"53","name":""}]}],"parent":"cdccbe7d26a5","note":"TEntity Get(TPrimaryKey id);\nTask&lt;TEntity&gt; GetAsync(TPrimaryKey id);\nTEntity Single(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\nTEntity FirstOrDefault(TPrimaryKey id);\nTask&lt;TEntity&gt; FirstOrDefaultAsync(TPrimaryKey id);\nTEntity FirstOrDefault(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\nTask&lt;TEntity&gt; FirstOrDefaultAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\nTEntity Load(TPrimaryKey id);\nGet方法被用于根据主键值(Id)取得对应的实体。当数据库中根据主键值找不到相符合的实体时,它会抛出异常。Single方法类似Get方法,但是它的输入参数是一个表达式而不是主键值(Id)。因此,我们可以写Lambda表达式来取得实体。示例如下:\nvar  person = _personRepository.Get(42);\nvar  person = _personRepository.Single(p =&gt; o.Name == &quot;Halil ibrahim Kalkan&quot;);\n注意,Single方法会在给出的条件找不到实体或符合的实体超过一个以上时,都会抛出异常。\nFirstOrDefault也一样,但是当没有符合Lambda表达式或Id的实体时,会返回null(取代抛出异常)。当有超过一个以上的实体符合条件,它只会返回第一个实体。\nLoad并不会从数据库中检索实体,但它会创建延迟执行所需的代理对象。如果你只使用Id属性,实际上并不会检索实体,它只有在你存取想要查询实体的某个属性时才会从数据库中查询实体。当有性能需求的时候,这个方法可以用来替代Get方法。Load方法在NHibernate与ABP的整合中也有实现。如果ORM提供者(Provider)没有实现这个方法,Load方法运行的会和Get方法一样。\nABP有些方法具有异步(Async)版本，可以应用在异步开发模型上(见Async方法相关章节)。"},{"tags":[{"text":"方法表","color":"#276F86","background":"#d6f0f8"}],"id":"86ccd53f7471","title":"取得实体列表(Getting list of entities)","children":[{"id":"67c341aeecbc","title":"GetAllList被用于从数据库中检索所有实体。重载并且提供过滤实体的功能","children":[],"parent":"86ccd53f7471","note":"var  allPeople = _personRespository.GetAllList();\nvar  somePeople = _personRepository.GetAllList(person =&gt; person.IsActive && person.Age &gt; 42);"},{"id":"064d8d7dec42","title":"GetAll返回IQueryable类型的对象。因此我们可以在调用完这个方法之后进行Linq操作","children":[],"parent":"86ccd53f7471","note":"var  query = from person in _personRepository.GetAll()\nwhere person.IsActive\norderby person.Name\nselect person;\nvar  people = query.ToList();\nList&lt;Person&gt; personList2 = _personRepository.GetAll().Where(p =&gt; p.Name.Contains(&quot;H&quot;)).OrderBy(p =&gt; p.Name).Skip(40).Take(20).ToList();\n\n如果调用GetAll方法,那么几乎所有查询都可以使用Linq完成。甚至可以用它来编写Join表达式。\n说明：关于IQueryable 当你调用GetAll这个方法在Repository对象以外的地方,必定会开启数据库连接。这是因为IQueryable允许延迟执行。它会直到你调用ToList方法或在forEach循环上(或是一些存取已查询的对象方法)使用IQueryable时,才会实际执行数据库的查询。因此,当你调用ToList方法时,数据库连接必需是启用状态。我们可以使用ABP所提供的UnitOfWork特性在调用的方法上来实现。注意,Application Service方法预设都已经是UnitOfWork。因此,使用了GetAll方法就不需要如同Application Service的方法上添加UnitOfWork特性。\n有些方法拥有异步版本,可应用在异步开发模型(见关于async方法章节)。"}],"parent":"cdccbe7d26a5","note":"List&lt;TEntity&gt; GetAllList();\nTask&lt;List&lt;TEntity&gt;&gt; GetAllListAsync();\nList&lt;TEntity&gt; GetAllList(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\nTask&lt;List&lt;TEntity&gt;&gt; GetAllListAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\nIQueryable&lt;TEntity&gt; GetAll();"},{"id":"f9814c0508c2","title":"自定义返回值(Custom return value)","children":[],"parent":"cdccbe7d26a5","note":"ABP也有一个额外的方法来实现IQueryable的延迟加载效果,而不需要在调用的方法上添加UnitOfWork这个属性卷标。\nT  Query&lt;T&gt;(Func&lt;IQueryable&lt;Tentity&gt;,T&gt; queryMethod);\n查询方法接受Lambda(或一个方法)来接收IQueryable并且返回任何对象类型。示例如下:\nvar  people = _personRepository.Query(q =&gt; q.Where(p =&gt; p.Name.Contains(&quot;H&quot;)).OrderBy(p =&gt; p.Name).ToList());\n因为是采用Lambda(或方法)在仓储对象的方法中执行,它会在数据库连接开启之后才被执行。你可以返回实体集合,或一个实体,或一个具部份字段(注: 非Select *)或其它执行查询后的查询结果集。"}],"parent":"0444fd4de8be","note":"IRepository定义了从数据库中检索实体的常用方法。"},{"id":"0ce250d1a0cf","title":"2. 新增(insert)","children":[{"id":"df6c2dcb1ed1","title":"IRepository接口定义了简单的方法来提供新增一个实体到数据库","children":[],"parent":"0ce250d1a0cf","note":"TEntity Insert(TEntity entity);\nTask&lt;TEntity&gt; InsertAsync(TEntity entity);\nTPrimaryKey InsertAndGetId(TEntity entity);\nTask&lt;TPrimaryKey&gt; InsertAndGetIdAsync(TEntity entity);\nTEntity InsertOrUpdate(TEntity entity);\nTask&lt;TEntity&gt; InsertOrUpdateAsync(TEntity entity);\nTPrimaryKey InsertOrUpdateAndGetId(TEntity entity);\nTask&lt;TPrimaryKey&gt; InsertOrUpdateAndGetIdAsync(TEntity entity);"}],"parent":"0444fd4de8be"},{"id":"a0ec4f327dc3","title":"3. 更新(UPDATE)","children":[{"id":"5c8376c2cb58","title":"IRepository定义一个方法来实现更新一个已存在于数据库中的实体","children":[],"parent":"a0ec4f327dc3","note":"IRepository定义一个方法来实现更新一个已存在于数据库中的实体。它更新实体并返回相同的实体对象。\nTEntity Update(TEntity entity);\nTask&lt;TEntity&gt; UpdateAsync(TEntity entity);"}],"parent":"0444fd4de8be","note":"IRepository定义一个方法来实现更新一个已存在于数据库中的实体。它更新实体并返回相同的实体对象。\nTEntity Update(TEntity entity);\nTask&lt;TEntity&gt; UpdateAsync(TEntity entity);"},{"id":"343f89f1e569","title":"4. 删除(Delete)","children":[{"id":"2121fa5145cf","title":"IRepository定了一些方法来删除已存在数据库中实体","children":[{"id":"436ef875e4ef","title":"要注意,所有符合predicate表达式的实体会先被检索而后删除。因此,使用上要很小心,这是有可能造成许多问题,假如果有太多实体符合条件","style":{"background-color":"#f68b1f"},"children":[],"parent":"2121fa5145cf"}],"parent":"343f89f1e569","note":"void Delete(TEntity entity);\nTask DeleteAsync(TEntity entity);\nvoid Delete(TPrimaryKey id);\nTask DeleteAsync(TPrimaryKey id);\nvoid Delete(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\nTask DeleteAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\n第一个方法接受一个现存的实体,第二个方法接受现存实体的Id。\n最后一个方法接受一个条件来删除符合条件的实体。要注意,所有符合predicate表达式的实体会先被检索而后删除。因此,使用上要很小心,这是有可能造成许多问题,假如果有太多实体符合条件。\n所有的方法都拥有async版本来应用在异步开发模型(见关于异步方法章节)。"}],"parent":"0444fd4de8be"},{"id":"986a8ca07448","title":"5. 其它方法(others)","children":[{"id":"e07b6699f0b0","title":"IRepository也提供一些方法来取得数据表中实体的数量","children":[{"id":"bc062f474de5","title":"Count","children":[],"parent":"e07b6699f0b0","note":""},{"id":"2cba144a531f","title":"LongCount","children":[],"parent":"e07b6699f0b0"}],"parent":"986a8ca07448","note":"int  Count();\nTask&lt;int&gt; CountAsync();\nint  Count(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\nTask&lt;int&gt; CountAsync(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\nLong  LongCount();\nTask&lt;long&gt; LongCountAsync();\nLong  LongCount(Expression&lt;Func&lt;TEntity, bool&gt;&gt; predicate);\nTask&lt;long&gt; LongCountAsync(Expression&lt;TEntity, bool&gt;&gt; predicate);\n所有的方法都拥有async版本被应用在异步开发模型(见关于异步方法章节)。"}],"parent":"0444fd4de8be"},{"id":"c6ca734bdcdc","title":"6. 关于异步方法(About Async methods)","children":[{"id":"f8a33278a980","title":"在这里有一个使用异步模型的application service方法的示例","children":[],"parent":"c6ca734bdcdc","note":"public class PersonAppService : AbpWpfDemoAppServiceBase, IPersonAppService \n{\n    private readonly IRepository&lt;Person&gt; _personRespository;\n    public PersonAppService(IRepository&lt;Person&gt; personRepository) \n    {\n        _personRepository = personRepository;\n    }\n\n    public async Task&lt;GetPersonOutput&gt; GetAllPeople() \n    {\n        var people = await _personRepository.GetAllListAsync();\n        return new GetPeopleOutput {\n                    People = Mapper.Map&lt;List&lt;PersonDto&gt;&gt;(people);\n                };\n    }\n}\nGetAllPeople方法是异步的并且使用GetAllListAsync与await关键字。Async不是在每个ORM框架都有提供。上例是从EF所提供的异步能力。如果ORM框架没有提供Async的仓储方法那么它会以同步的方式操作。同样地,举例来说,InsertAsync操作起来和EF的新增是一样的,因为EF会直到单元作业(unit of work)完成之后才会写入新实体到数据库中(DbContext.SaveChanges)。"}],"parent":"0444fd4de8be"}],"parent":"56a2f0d77d4e","note":"在ABP中,仓储类要实现IRepository接口。最好的方式是针对不同仓储对象定义各自不同的接口。\n针对Person实体的仓储接口声明的示例如下所示:\npublic interface IPersonRepository : IRepository&lt;Person&gt; { }\nIPersonRepository继承自IRepository，用来定义Id的类型为int(Int32)的实体。如果你的实体Id数据类型不是int,你可以继承IRepository接口，如下所示:\npublic interface IPersonRepository : IRepository&lt;Person, long&gt; { }\n对于仓储类，IRepository定义了许多泛型的方法。比如: Select,Insert,Update,Delete方法(CRUD操作)。在大多数的时候,这些方法已足已应付一般实体的需要。如果这些方对于实体来说已足够,我们便不需要再去创建这个实体所需的仓储接口/类。在Implementation章节有更多细节。","collapsed":false},{"id":"4ec345100fe3","title":"仓储的实现","children":[{"tags":[{"text":"NHibernate","color":"#276F86","background":"#d6f0f8"},{"text":"EntityFramework","color":"#276F86","background":"#d6f0f8"}],"id":"439226f0c2f0","title":"只要实现IRepository接口,任何框架都可以使用","children":[],"parent":"4ec345100fe3","note":"ABP在设计上是采取不指定特定ORM框架或其它存取数据库技术的方式。只要实现IRepository接口,任何框架都可以使用。\n仓储要使用NHibernate或EF来实现都很简单。见实现这些框架在ABP仓储对象上一文:\nNHibernate\nEntityFramework\n当你使用NHibernate或EntityFramework,如果提供的方法已足够使用,你就不需要为你的实体创建仓储对象了。我们可以直接注入IRepository(或IRepository)。下面的示例为application service使用仓储对象来新增实体到数据库:\npublic class PersonAppService : IPersonAppService \n{\n    private readonly IRepository&lt;Person&gt; _personRepository;\n\n    public PersonAppService(IRepository&lt;Person&gt; personRepository) {\n        _personRepository = personRepository;\n    }\n\n    public void CreatePerson(CreatePersonInput input) {\n        person = new Person { Name = input.Name, EmailAddress = input.EmailAddress; };\n        _personRepository.Insert(person);\n    }\n}\nPersonAppService的建构子注入了IRepository并且使用其Insert方法。当你有需要为实体创建一个定制的仓储方法,那么你就应该创建一个仓储类给指定的实体。"}],"parent":"56a2f0d77d4e"},{"id":"5b973ac44471","title":"管理数据库连接","children":[{"tags":[{"text":"多库事务","color":"#276F86","background":"#d6f0f8"}],"id":"ab788d37a34b","title":"数据库连接的开启和关闭，在仓储方法中,ABP会自动化的进行连接管理","children":[],"parent":"5b973ac44471","note":"当仓储方法被调用后,数据库连接会自动开启且启动事务。当仓储方法执行结束并且返回以后,所有的实体变化都会被储存, 事务被提交并且数据库连接被关闭,一切都由ABP自动化的控制。如果仓储方法抛出任何类型的异常,事务会自动地回滚并且数据连接会被关闭。上述所有操作在实现了IRepository接口的仓储类所有公开的方法中都可以被调用。\n如果仓储方法调用其它仓储方法(即便是不同仓储的方法),它们共享同一个连接和事务。连接会由仓储方法调用链最上层的那个仓储方法所管理。更多关于数据库管理,详见UnitOfWork文件。"}],"parent":"56a2f0d77d4e"},{"id":"2076ac09607f","title":"仓储的生命周期","children":[{"id":"a8e72990d032","title":"所有的仓储对象都是暂时性的","children":[],"parent":"2076ac09607f","note":"所有的仓储对象都是暂时性的。这就是说,它们是在有需要的时候才会被创建。ABP大量的使用依赖注入，当仓储类需要被注入的时候,新的类实体会由注入容器会自动地创建。"}],"parent":"56a2f0d77d4e"},{"id":"ad62a7c1a370","title":"仓储的最佳实践","children":[{"id":"43fc36391fd5","title":"对于一个T类型的实体,是可以使用IRepository。但别任何情况下都创建定制化的仓储,除非我们真的很需要。预定义仓储方法已经足够应付各种案例","children":[],"parent":"ad62a7c1a370"},{"id":"02512bdae15b","title":"假如你正创建定制的仓储(可以实现IRepository)","children":[],"parent":"ad62a7c1a370"},{"id":"0a614ede47dc","title":"仓储类应该是无状态的。这意味着, 你不该定义仓储等级的状态对象并且仓储方法的调用也不应该影响到其它调用。","children":[],"parent":"ad62a7c1a370"},{"id":"6c96d89a9d28","title":"当仓储可以使用相依赖注入，尽可较少或是不相根据于其它服务","children":[],"parent":"ad62a7c1a370"}],"parent":"56a2f0d77d4e","icons":[{"index":"32","color":"rgb(255, 0, 0)","name":"flag"}]}],"parent":"f5f9711dd7b1","icons":[{"index":"42","name":""}]},{"id":"43239bca5441","title":"领域服务","children":[{"id":"49acce31363c","title":"领域服务（或者服务，在DDD模式中）是被用来执行领域操作或者业务规则的","children":[{"id":"5efd74eba50e","title":"一个好的Service应该有以下三个特征","children":[{"id":"fadb600ad71b","title":"与领域概念相关的操作不是Entity或Value Object 的一个自然部分","children":[],"parent":"5efd74eba50e"},{"id":"a756bdd0e221","title":"接口是根据领域模型的其它元素定义的","children":[],"parent":"5efd74eba50e"},{"id":"bbee79e8670a","title":"操作是无状态的","style":{"background-color":"#f384ae"},"children":[],"parent":"5efd74eba50e"}],"parent":"49acce31363c"},{"id":"20902dc0f35e","title":"领域服务和Application Services 是不同的，Application Services 返回的是DTO，而领域服务返回的是领域对象（实体或者值类型）。","children":[],"parent":"49acce31363c","note":"\n领域服务和Application Services 是不同的，Application Services 返回的是DTO，而领域服务返回的是领域对象（实体或者值类型）。\n领域服务可以被应用服务和其它的领域服务调用，但是不可以被表现层直接调用（表现层可以直接调用应用服务）。"},{"id":"b7770e4f4666","title":"领域服务可以被应用服务和其它的领域服务调用，但是不可以被表现层直接调用（表现层可以直接调用应用服务）。","children":[],"parent":"49acce31363c","note":""}],"parent":"43239bca5441","note":""},{"id":"7b02cd827d73","title":"IDomainService 和 DomainService","children":[{"tags":[{"text":"DomainService可以被继承","color":"#276F86","background":"#d6f0f8"}],"id":"39f5ff72651c","title":" IDomainService 接口，所有的领域服务都必须实现该接口（记住这是一个约定）","children":[],"parent":"7b02cd827d73","note":"ABP 定义了一个 IDomainService 接口，所有的领域服务都必须实现该接口（记住这是一个约定），一旦实现了这个接口，那么领域服务就会通过Dependency Injection 自动的注册到系统中作为一个暂时对象（Transient）。\n领域服务也可以继承自 DomainService 类（这是可选的）。 因此，它可以用一些继承而来的属性来做日志记录，本地化等等；即使你不继承该类，如果你需要这些属性也是可以被注入的。"}],"parent":"43239bca5441"},{"id":"ac0a53ad3377","title":"实例","children":[{"id":"e3b4c5d06347","title":"假设我们有一个任务管理系统，并且我们有这样的业务规则， 把任务分配到个人","children":[{"tags":[{"text":"最佳实践","color":"#276F86","background":"#d6f0f8"}],"id":"0a1c140988c2","title":"1. 创建一个接口","children":[],"parent":"e3b4c5d06347","note":"首先，我们为这个服务定义一个接口（不是必须的，但是一个好的实践）：\npublic interface ITaskManager : IDomainService\n{\n    void AssignTaskToPerson(Task task, Person person);\n}\n正如你所看到的，TaskMananger 用到了领域对象 ：Task 和 Person 。这里有一些领域服务的命名约定；例如：TaskMananger, TaskService 或者 TaskDomainService 等等。"},{"id":"8115b0714d9e","title":"2. 实现服务","children":[],"parent":"e3b4c5d06347","note":"实现如下：\npublic class TaskManager : DomainService, ITaskManager\n{\n    public const int MaxActiveTaskCountForAPerson = 3;\n\n    private readonly ITaskRepository _taskRepository;\n\n    public TaskManager(ITaskRepository taskRepository)\n    {\n        _taskRepository = taskRepository;\n    }\n\n    public void AssignTaskToPerson(Task task, Person person)\n    {\n        if (task.AssignedPersonId == person.Id)\n        {\n            return;\n        }\n\n        if (task.State != TaskState.Active)\n        {\n            throw new ApplicationException(&quot;Can not assign a task to a person when task is not active!&quot;);\n        }\n\n        if (HasPersonMaximumAssignedTask(person))\n        {\n            throw new UserFriendlyException(L(&quot;MaxPersonTaskLimitMessage&quot;, person.Name));\n        }\n\n        task.AssignedPersonId = person.Id;\n    }\n\n    private bool HasPersonMaximumAssignedTask(Person person)\n    {\n        var assignedTaskCount = _taskRepository.Count(t =&gt; t.State == TaskState.Active && t.AssignedPersonId == person.Id);\n        return assignedTaskCount &gt;= MaxActiveTaskCountForAPerson;\n    }\n}\n我们有如下两个业务规则：\n分配给Person的任务状态应该是Active状态\nPerson最多只能接受3个任务\n你可能感到奇怪， 为啥我在做第一次检测的时候为什么我抛出了一个ApplicationException异常，第二次检测时抛出UserFriendlyException 异常。这个和领域服务没有半毛钱关系；我这样做仅仅是为了提供一个示例。这完全取决于你。我认为用户界面必须获取到任务状态和分配数量错误时的错误消息。并且我认为这是一个应用级的错误，我们可以不向用户展示这个难以理解的错误，我们应该向用户展示一个可读性好的错误消息。这仅仅是一个示例。"},{"id":"30609edc6c63","title":"3 应用层调用领域服务","children":[],"parent":"e3b4c5d06347","note":"下面示例为我们展示了应用层是如何调用TaskMananger:\npublic class TaskAppService : ApplicationService, ITaskAppService\n{\n    private readonly IRepository&lt;Task, long&gt; _taskRepository;\n    private readonly IRepository&lt;Person&gt; _personRepository;\n    private readonly ITaskManager _taskManager;\n\n    public TaskAppService(IRepository&lt;Task, long&gt; taskRepository, IRepository&lt;Person&gt; personRepository , ITaskManager taskManager)\n    {\n        _taskRepository = taskRepository;\n        _personRepository = personRepository;\n        _taskManager = taskManager;\n    }\n\n    public void AssignTaskToPerson(AssignTaskToPersonInput input)\n    {\n        var task = _taskRepository.Get(input.TaskId);\n        var person = _personRepository.Get(input.PersonId);\n\n        _taskManager.AssignTaskToPerson(task, person);\n    }\n}\n任务服务层用给定的DTO和仓储资源去检索相关的Task和Person，并且将检索到的结果传递给TaskMananger（领域服务）。"}],"parent":"ac0a53ad3377"},{"id":"56574c2546b5","title":"探讨，基于上面的示例，你可能有一些疑问","children":[{"id":"33624180d2f6","title":"1. 为什么不只在应用层实现这些逻辑？","children":[{"id":"de056ded02b4","title":"领域层里的业务规则重用我想要重用","style":{"background-color":"#80bc42"},"children":[],"parent":"33624180d2f6"},{"id":"d350f64f2766","title":"领域层为什么无状态也是为了重用业务规则","children":[],"parent":"33624180d2f6"}],"parent":"56574c2546b5","note":"你可能会说为什么不在服务层来实现领域服务里面的业务逻辑。\n我们可以简单的说因为这根本不是应用层的任务。因为它不是一个use-case(用例)，而是一个业务操作。我们可以用同样（分配任务给用户）的逻辑在不同的用例中。 我们可能会有另外的应用场景，以某种方式更新任务并且这个更新可能包含了分配任务给另外的人。所以，我们可以在这里用相同的领域逻辑。（说白了就是业务规则重用）还有就是，我们可以有2中不同的UI（手持设备应用和Web应用）可以共享相同的领域。\n如果你的业务领域相对简单，那么你可以不考虑使用领域服务来实现这些逻辑。在DDD模式中这不是一个最佳实践，但ABP不会强迫你使用这种设计模式。"},{"id":"f24b7d1df265","title":"2. 为什么一定要使用领域服务？","children":[{"id":"9b05343ca893","title":"将业务规则封装到领域层的实体中，使得应用层不可以更改规则。","style":{"background-color":"#80bc42"},"children":[],"parent":"f24b7d1df265"}],"parent":"56574c2546b5","note":"看如下示例：\npublic void AssignTaskToPerson(AssignTaskToPersonInput input)\n{\n    var task = _taskRepository.Get(input.TaskId);\n\n    task.AssignedPersonId = input.PersonId;\n}\n写这个应用的开发人员可能不知道这里是一个TaskMananger，并直接给任务的AssignedPersonId 分配了 PersonId。 那么，怎么阻止这个的发生呢？在DDD社区有很多关于应该采用那种设计模式的探讨。我们不会做深入的探讨。但是我们会用一个简单的方式来实现。\n我们可以改变Task实体，如下所示：\npublic class Task : Entity&lt;long&gt;\n{\n    public virtual int? AssignedPersonId { get; protected set; }\n\n    //...other members and codes of Task entity\n\n    public void AssignToPerson(Person person, ITaskPolicy taskPolicy)\n    {\n        taskPolicy.CheckIfCanAssignTaskToPerson(this, person);\n\n        AssignedPersonId = person.Id;\n    }\n}\n我们给属性AssignedPersonId 的set设置为protected。所以，这个属性不可以被外部类修改。添加一个AssignToPerson方法，该方法接受参数类型Person和ITaskPolicy。ITaskPolicy 接口有一个CheckIfCanAssignTaskToPerson 方法来验证任务是否能分配给Person，如果验证不通过将会抛出一个适当的异常。那么应用层的方法将会如下所示：\npublic void AssignTaskToPerson(AssignTaskToPersonInput input)\n{\n    var task = _taskRepository.Get(input.TaskId);\n    var person = _personRepository.Get(input.PersonId);\n\n    task.AssignToPerson(person, _taskPolicy);\n}\n现在，没有第二种方式将任务分配给个人。我们应该总是使用AssignToPerson 并且不可以跳过该业务规则。"}],"parent":"ac0a53ad3377"}],"parent":"43239bca5441","icons":[{"index":"48","name":""}]}],"parent":"f5f9711dd7b1","icons":[{"index":"23","name":"completion"}]},{"id":"ca1e2bf486d0","title":"工作单元","children":[{"id":"083e65b97c21","title":"通用连接和事务管理方法","children":[{"id":"98a174bdda1a","title":"第一个方法:在Web请求Application_BeginRequest&nbsp;开，EndRequest&nbsp;关","children":[{"id":"d40c9e38de61","title":"简易但却没效率","children":[{"id":"515af27cfc20","title":"或许这个Web请求不需要操作数据库,但是连接却会开启","children":[],"parent":"d40c9e38de61"},{"id":"95c221a2de72","title":"这可能会让Web请求的运行时间变长,并且数据库操作还会需要一些执行","children":[],"parent":"d40c9e38de61"},{"id":"1278fcf6ceaa","title":"如果你的应用程序是Widnows Service,这可能就无法被实现了","children":[],"parent":"d40c9e38de61"}],"parent":"98a174bdda1a"},{"id":"c50bfd2dd3b7","title":"同样的这是一个使用事务式的数据库操作最佳场景。如果有一个操作发生失败,所有的操作都会回滚。因为事务会锁住数据库中的一些数据列(事件数据表),它必定要是短暂的。<br>","children":[],"parent":"98a174bdda1a"}],"parent":"083e65b97c21"},{"id":"dc129e32dddc","title":"第二个方法：创建一个连接当需要的时候(只要在使用它之前)并且释放它在使用它之后","children":[],"parent":"083e65b97c21","note":"这是相当高效的,但是就得乏味而且反复的去进行（创建/释放连接）。"}],"parent":"ca1e2bf486d0"},{"id":"f865a574e8ac","title":"ABP的连接和事务管理","children":[{"id":"ed3fe3c778a8","title":"综合上述两个连接管理的方法，提供一个简单而高效的模型","children":[{"tags":[{"text":"IContentRepository","color":"#276F86","background":"#d6f0f8"}],"id":"cb26bd998d8b","title":"1. 仓储类(Repository classes)","children":[],"parent":"ed3fe3c778a8","note":"仓储是主要的数据库操作的类。ABP开启了一个数据库连接并且在进入到仓储方法时会启用一个事务。因此,你可以安全地使用连接于仓储方法中。在仓储方法结束后,事务会被提交并且会释放掉连接。假如仓储方法抛出任何异常,事务会被回滚并且释放掉连接。在这个模式中,仓储方法是单元性的(一个工作单元unit of work)。ABP在处理上述那些动作都是全自动的。在这里,有一个简单的仓储:\npublic class ContentRepository : NhRepositoryBase&lt;Content&gt;, IContentRepository {\n      public List&lt;Content&gt; GetActiveContents(string searchCondition) {\n         var query = from content in Session.Query&lt;Content&gt;()\n                           where content.IsActive && !content.IsDeleted\n                           select content;\n\n         if(string.IsNullorEmpty(searchCondition)) {\n            query = query.Where(content =&gt; content.Text.Contains(searchCodition));\n         }\n\n         return query.ToList();\n      }\n   }\n这个示例使用NHibernate作为ORM框架。如上所示,不需要撰写任何数据库连接操作(NHibernate中的Session)的程序代码。\n假如仓储方法调用另一个仓储方法(一般来说,若工作单元方法调用另一个工作单元的方法),都使用同一个连接和事务。第一个被调用到的仓储方法负责管理连接和事务,而其余被它调用的仓储方法则只单纯使用不管理。+\n\n"},{"tags":[{"text":"IPersonAppService","color":"#276F86","background":"#d6f0f8"}],"id":"23578fd58d67","title":"2. 应用服务(Application service classes)","children":[],"parent":"ed3fe3c778a8","note":"一个应用服务的方法也被考虑使用工作单元。如果我们拥有一个应用服务方法如下:\n  public class PersonAppService : IPersonAppService {\n      private readonly IPersonRepository _personRepository;\n      private readonly IStatisticsRepository _statisticsRepository;\n\n      public PersonAppService(IPersonRepository personRepository, IStatisticsRepository statisticsRepository) {\n         _personRepository = personRepository;\n         _statisticsRepository = statisticsRepository;\n      }\n\n      public void CreatePerson(CreatePersonInput input) {\n     var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };\n        _personRepository.Insert(person);\n        _statisticsRepository.IncrementPeopleCount();      \n    }\n  }\n在CreatePerson方法中,我们新增一个person使用person仓储并且使用statistics仓储增加总people数量。两个仓储共享同一个连接和事务于这个例子中,因为这是一个应用服务的方法。ABP开启一个数据库连接并且开启一个事务于进入到CreationPerson这个方法,若没有任何异常抛出,接着提交这个事务于方法结尾时,若有异常被抛出,则会回滚这个事务。在这种机制下,所有数据库的操作在CreatePerson中,都成了单元性的了(工作单元)。"},{"tags":[{"text":"[UnitOfWork]","color":"#276F86","background":"#d6f0f8"},{"text":"IUnitOfWorkManager","color":"#276F86","background":"#d6f0f8"}],"id":"349dcf3703a6","title":"3. 工作单元(Unit of work)","children":[{"tags":[{"text":"UnitOfWork","color":"#276F86","background":"#d6f0f8"},{"text":"IsDisabled属性","color":"#276F86","background":"#d6f0f8"},{"text":"禁用可以被忽略","color":"#276F86","background":"#d6f0f8"}],"id":"2ee13f659e50","title":"1. 禁用工作单元(Disabling unit of work)","children":[{"id":"bbabf9db7661","title":"你的方法不需要任何数据库操作且你不想要开启那些不需要的数据库连接","children":[],"parent":"2ee13f659e50"},{"id":"8ef6de8bdd3c","title":"你想要使用工作单元于UnitOfWorkScope类的有限范围内,如上所述","children":[],"parent":"2ee13f659e50"}],"parent":"349dcf3703a6","note":"你或许会想要禁用应用服务方法的工作单元(因为它默认是启用的)。要想做到这个,使用UnitOfWorkAttribute的IsDisabled属性。示例如下:\n   [UnitOfWork(IsDisabled = true)]\n   public virtual void RemoveFriendship(RemoveFriendInput input) {\n      _friendshipRepository.Delete(input.Id);\n   }\n平常时, 你不会需要这么做,这是因为应用服务的方法都应该是单元性且通常是使用数据库。在有些情况下,你或许会想要禁用应用服务的工作单元:\n你的方法不需要任何数据库操作且你不想要开启那些不需要的数据库连接\n你想要使用工作单元于UnitOfWorkScope类的有限范围内,如上所述\n注意,如果工作单元方法调用这个RemoveFriendship方法,禁用被忽略且它和调用它的方法使用同一个工作单元。因此,使用禁用这个功能要很小心。同样地,上述程序代码工作的很好,因为仓储方法默认即为工作单元。+\n\n"},{"tags":[{"text":"[UnitOfWork(false)]","color":"#276F86","background":"#d6f0f8"}],"id":"b6aecb251cc9","title":"2. 无事务的工作单元(Non-transactional unit of work)","children":[{"id":"612b56d0edbb","title":"建议[UnitOfWork(isTransaction:false)]。(具有可读性并且明确)。","children":[],"parent":"b6aecb251cc9"},{"id":"5825c60f1d00","title":"如果你的方法只是读取数据,不改变数据,那么当然可以采用非事务性","children":[],"parent":"b6aecb251cc9"}],"parent":"349dcf3703a6","note":"工作单元默认上是具事务性的(这是它的天性)。因此,ABP启动/提交/回滚一个显性的数据库等级的事务。在有些特殊案例中,事务可能会导致问题,因为它可能会锁住有些数据列或是数据表于数据库中。在此这些情境下, 你或许会想要禁用数据库等级的事务。UnitOfWork属性可以从它的建构子中取得一个布尔值来让它如非事务型工作单元般工作着。示例为:\n   [UnitOfWork(false)]\n   public GetTasksOutput GetTasks(GetTasksInput input) {\n      var tasks = _taskRepository.GetAllWithPeople(input.AssignedPersonId, input.State);\n      return new GetTasksOutput {\n                          Tasks = Mapper.Map&lt;List&lt;TaskDto&gt;&gt;(tasks)\n                       };\n   }\n建议可以这么做[UnitOfWork(isTransaction:false)]。(具有可读性并且明确)。\n注意,ORM框架(像是NHibernate和EntityFramework)会在单一命令中于内部进行数据储存。假设你更新了一些的实体于非事务的UoW。即便于这个情境下所有的更新都会于单一数据库命令的工作单元尾部完成。但是,如果你直接执行SQL查询,它会立即被执行。\n这里有一个非事务性UoW的限制。如果你已经位于事务性UoW区域内,设定isTransactional为false这个动作会被忽略。\n使用非事务性UoW要小心,因为在大多数的情况下,数据整合应该是具事务性的。如果你的方法只是读取数据,不改变数据,那么当然可以采用非事务性。"},{"id":"7f0f3040313f","title":"3. 工作单元调用其它工作单元(A unit of work method calls another)","children":[],"parent":"349dcf3703a6","note":"若工作单元方法(一个贴上UnitOfWork属性标签的方法)调用另一个工作单元方法,他们共享同一个连接和事务。第一个方法管理连接,其它的方法只是使用它。这在所有方法都执行在同一个线程下是可行的(或是在同一个Web请求内)。实际上,当工作单元区域开始,所有的程序代码都会在同一个线程中执行并共享同一个连接事务,直到工作单元区域终止。这对于使用UnitOfWork属性和UnitOfWorkScope类来说都是一样的。如果你创建了一个不同的线程/任务,它使用自己所属的工作单元。"},{"tags":[{"text":"不用显示调用SaveChagnes","color":"#276F86","background":"#d6f0f8"},{"text":"ABP自动持久化","color":"#276F86","background":"#d6f0f8"}],"id":"adab43ae138e","title":"4. 自动化的saving changes (Automatically saving changes)","children":[],"parent":"349dcf3703a6","note":"当我们使用工作单元到方法上,ABP自动的储存所有变化于方法的末端。假设我们需要一个可更新person名称的方法:\n [UnitOfWork]\n   public void UpdateName(UpdateNameInput input) {\n      var person = _personRepository.Get(input.PersonId);\n      person.Name = input.NewName;\n   }\n就这样,名称就被修改了!我们甚至没有调用_personRepository.Update方法。ORM框架会持续追踪实体所有的变化于工作单元内,且反映所有变化到数据库中。\n注意,这不需要在应用服务声明UnitOfWork,因为它们默认就是采用工作单元。"},{"id":"0e3eb6a64821","title":"5. 仓储接口的GetAll()方法(IRepository.GetAll() method)","style":{"background-color":"#f15a23"},"children":[],"parent":"349dcf3703a6","note":"当你在仓储方法外调用GetAll方法, 这必定得有一个开启状态的数据库连接,因为它返回IQueryable类型的对象。这是需要的,因为IQueryable延迟执行。它并不会马上执行数据库查询,直到你调用ToList()方法或在foreach循环中使用IQueryable(或是存取被查询结果集的情况下)。因此,当你调用ToList()方法,数据库连接必需是启用状态。示例:\n [UnitOfWork]\n   public SearchPeopleOutput SearchPeople(SearchPeopleInput input) {\n      //取得 IQueryable&lt;Person&gt;\n      var query = _personRepository.GetAll();\n\n      //若有选取,则添加一些过滤条件\n      if(!string.IsNullOrEmpty(input.SearchedName)) {\n         query = query.Where(person =&gt; person.Name.StartsWith(input.SearchedName));\n      }\n\n      if(input.IsActive.HasValue) {\n         query = query.Where(person =&gt; person.IsActive == input.IsActive.Value);\n      }\n\n      //取得分页结果集\n      var people = query.Skip(input.SkipCount).Take(input.MaxResultCount).ToList();\n\n      return new SearchPeopleOutput { People = Mapper.Map&lt;List&lt;PersonDto&gt;&gt;(people) };\n   }\n在这里,SearchPeople方法必需是工作单元,因为IQueryable在被调用ToList()方法于方法本体内,并且数据库连接必须于IQueryable.ToList()被执行时开启。\n一如GetAll()方法,如果需要数据库连接且没有仓储的情况下,你就必须要使用工作单元。注意,应用服务方法默认就是工作单元。\n工作单元属性的限制(UnitOfWork attribute restrictions)\n在下面情境下你可以使用UnitOfWork属性标签:\n类所有public或public virtual这些基于界面的方法(像是应用服务是基于服务界面)\n自我注入类的public virtual方法(像是MVC Controller和Web API Controller)\n所有protected virtual方法。\n建议将方法标示为virtual。你无法应用在private方法上。因为,ABP使用dynamic proxy来实现,而私有方法就无法使用继承的方法来实现。当你不使用依赖注入且自行初始化类,那么UnitOfWork属性(以及任何代理)就无法正常运作。"}],"parent":"ed3fe3c778a8","note":"工作单元在后台替仓储和应用服务的方法工作。假如你想要控制数据库的连接和事务,你就需要直接操作工作单元。下面有两个直接使用的示例:\n首要且最好的使用UnitOfWorkAttribute的方式如下:\n[UnitOfWork]\n   public void CreatePerson(CreatePersonInput input) {\n      var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };\n      _personRepository.Insert(person);\n      _statisticsRepository.IncrementPeopleCount();\n   }\n因此,CreatePerson方法转变成工作单元并且管理数据库连接和事务,两个仓储对象都使用相同的工作单元。要注意,假如这是应用服务的方法则不需要添加UnitOfWork属性，见工作单元方法:第三章,3.3.5。\n第二个示例是使用IUnitOfWorkManager.Begin(...)方法如下所示:\n public class MyService {\n      private readonly IUnitOfWorkManager _unitOfWorkManager;\n      private readonly IPersonRepository _personRepository;\n      private readonly IStatisticsRepository _statisticsRepository;\n\n      public MyService(IUnitOfWorkManager unitOfWorkManager, IPersonRepository personRepository, IStatisticsRepository statisticsRepository) {\n         _unitOfWorkManager = unitOfWorkManager;\n         _personRepository = personRepository;\n         _statisticsRepository = statisticsRepository;\n      }\n\n      public void CreatePerson(CreatePersonInput input) {\n         var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };\n         using(var unitOfWork = _unitOfWorkManager.Begin()) {\n            _personRepository.Insert(person);\n            _statisticsRepository.IncrementPeopleCount();\n            unitOfWork.Complete();\n         }\n      }\n   }\n你可以注入并且使用IUnitOfWorkManager，如上所示。因此,你可以创建更多的有限范围 （limited scope）的工作单元。在这个机制中,你通常可以手动调用Complete方法。如果你不调用,事务会回滚并且所有的异常都不会被储存。Begin方法被重写从而设置工作单元的选项。\n这很棒,不过除非你有很好的理由,否则还是少用UnitOfWork属性。"},{"id":"207ada5fd1ce","title":"4 选项","children":[],"parent":"ed3fe3c778a8","note":"有许多可以用来控制工作单元的选项。\n首先,我们可以在startup configuration中改变所有工作单元的所有默认值。这通常是用了我们模块中的PreInitialize方法来实现。\n   public class SimpleTaskSystemCoreModule : AbpModule {\n      public override void PreInitialize() {\n         Configuration.UnitOfWork.IsolationLevel = IsolationLevel.ReadCommitted;\n         Configuration.UnitOfWork.Timeout = TimeSpan.FromMinutes(30);\n      }\n\n       //...其它模块方法\n   }"},{"id":"da9b3569edb4","title":"5 方法","children":[{"id":"03015426fbd2","title":"在工作单元的过程中就储存所有变化","children":[],"parent":"da9b3569edb4"}],"parent":"ed3fe3c778a8","note":"工作单元系统运作是无缝且不可视的。但是,在有些特例下,你需要调用它的方法。\nSaveChanges\nABP储存所有的变化于工作单元的尾端,你不需要做任何事情。但是,有些时候,你或许会想要在工作单元的过程中就储存所有变化。在这个案例中,你可以注入IUnitOfWorkManager并且调用IUnitOfWorkManager.Current.SaveChanges()方法。示例中以Entity Framework在储存变化时取得新增实体的Id。注意,当前工作单元是具事务性的,所有在事务中的变化会在异常发生时都被回滚,即便是已调用SaveChange。"},{"id":"f8fa7052681c","title":"6 事件","children":[],"parent":"ed3fe3c778a8","note":"工作单元具有Completed/Failed/Disposed事件。你可以注册这些事件并且进行所需的操作。注入IUnitOfWorkManager并且使用IUnitOfWorkManager.Current 属性来取得当前已激活的工作单元并且注册它的事件。\n你或许会想要执行有些程序代码于当前工作单元成功地完成。示例:\n public void CreateTask(CreateTaskInput input) {\n      var task = new Task { Description = input.Description };\n      if(input.AssignedPersonId.HasValue) {\n         task.AssignedPersonId = input.AssignedPersonId.Value;\n         _unitOfWorkManager.Current.Completed += (sender, args) =&gt; { // };\n      }\n      _taskRepository.Insert(task);\n   }"}],"parent":"f865a574e8ac"}],"parent":"ca1e2bf486d0"}],"parent":"f5f9711dd7b1","icons":[{"index":"52","name":""}]},{"id":"935fc94ab6d3","title":"领域事件","parent":"f5f9711dd7b1","children":[{"id":"72ee32f7001d","title":"在应用系统中，领域事件被用于解耦并且重用(re-use)商业逻辑","parent":"935fc94ab6d3","children":[],"note":"在C#中,一个类可以定义其专属的事件并且其它类可以注册该事件并监听，当事件被触发时可以获得事件通知。这对于对于桌面应用程序或独立的Windows Service来说非常有用。但是, 对于Web应用程序来说会有点问题,因为对象是根据请求(request)被创建并且它们的生命周期都很短暂。我们很难注册其它类别的事件。同样地,直接注册其它类别的事件也造成了类之间的耦合性。"},{"id":"75a8061edf11","title":"事件总线","parent":"935fc94ab6d3","children":[{"id":"1502602ef63a","title":"1. 获取默认实例( Getting the default instance)","parent":"75a8061edf11","children":[],"note":"你可以直接使用EventBus.Default。它是全局事件总线并且可以如下方式使用:\nEventBus.Default.Trigger(...); //触发事件"},{"id":"a28a4a278b5d","title":"2. 注入IEventBus事件接口(Injecting IEventBus)","parent":"75a8061edf11","children":[],"note":"除了直接使用EventBus.Default外,你还可以使用依赖注入(DI)的方式来取得IEventBus的参考。这利于进行单元测试。在这里,我们使用属性注入的范式:\n public class TaskAppService : ApplicaService {\n      public IEventBus EventBus { get; set; }\n      public TaskAppService() {\n         EventBus = NullEventBus.Instance;\n      }\n   }\n注入事件总线,采用属性注入比建构子注入更适合。事件是由类所描述并且该事件对象继承自EventData。假设我们想要触发某个事件于某个任务完成后:\n   public class TaskCompletedEventData : EventData {\n      public int TaskId { get; set; }\n   }\n这个类所包含的属性都是类在处理事件时所需要的。EventData类定义了EventSource(那个对象触发了这个事件)和EventTime(何时触发)属性。"}],"note":"事件总线为一个单体(singleton)的对象,它由所有其它类所共享,可通过它触发和处理事件。要使用这个事件总线,你需要引用它。你可以用两种方式来实现:"},{"id":"a805f0e45bb8","title":"定义事件","parent":"935fc94ab6d3","children":[],"note":"ABP定义AbpHandledExceptionData事件并且在异常发生的时候自动地触发这个事件。这在你想要取得更多关于异常的信息时特别有用(即便ABP已自动地纪录所有的异常)。你可以注册这个事件并且设定它的触发时机是在异常发生的时候。\nABP也提供在实体变更方面许多的通用事件数据类: EntityCreatedEventData, EntityUpdatedEventData和EntityDeletedEventData。它们被定义在Abp.Events.Bus.Entitis命名空间中。当某个实体新增/更新/删除后,这些事件会由ABP自动地触发。如果你有一个Person实体,可以注册到EntityCreatedEventData,事件会在新的Person实体创建且插入到数据库后被触发。这些事件也支持继承。如果Student类继承自Person类,并且你注册到EntityCreatedEventData中,接着你将会在Person或Student新增后收到触发。"},{"id":"5e981bd9eaa7","title":"触发事件","parent":"935fc94ab6d3","children":[],"note":"触发事件的范例如下:\n   public class TaskAppService : ApplicationService {\n      public IEventBus EventBus { get; set; }\n      public TaskAppService() {\n         EventBus = NullEventBus.Instance;\n      }\n\n      public void CompleteTask(CompleteTaskInput input) {\n         //TODO: 已完成数据库上的任务\n         EventBus.Trigger(new TaskCompletedEventData { TaskId = 42 } );\n      }\n   }\n这里有一些触发方法的重载:\n   EventBus.Trigger&lt;TaskcompletedEventData&gt;(new TaskCompletedEventData { TaskId = 42});\n   EventBus.Trigger(this, new TaskCompletedEventData { TaskId = 42 });\n   EventBus.Trigger(typeof(TaskCompletedEventData), this, new TaskCompletedEventData { TaskId = 42});\n"},{"id":"646cadfc4c07","title":"事件处理","parent":"935fc94ab6d3","children":[{"id":"ec6f8ff4a973","tags":[{"text":"IEventHandler","color":"#276F86","background":"#d6f0f8"},{"text":"支持继承","color":"#276F86","background":"#d6f0f8"}],"title":"1. 基础事件的处理(Handling base events)","parent":"646cadfc4c07","children":[],"note":"EventBus支持事件的继承。举例来说,你可以创建TaskEventData以及两个继承类:TaskCompletedEventData和TaskCreatedEventData:\n  public class TaskEventData : EventData {\n      public Task Task { get; set; }\n   }\n\n   public class TaskCreatedEventData : TaskEventData {\n      public User CreatorUser { get; set; }\n   }\n\n   public class TaskCompletedEventData : TaskEventData {\n      public User CompletorUser { get; set; }\n   }\n然而,你可以实现IEventHandler来处理这两个事件:\n   public class ActivityWriter : IEventHandler&lt;TaskEventData&gt;, ITransientDependency {\n      public void HandleEvent(TaskEventData eventData) {\n         if(eventData is TaskCreatedEventData) {\n            ...\n         }else{\n            ...\n         }\n      }\n   }\n当然,你也可以实现IEventHandler来处理所有的事件,如果你真的想要这样做的话(译者注:作者不太建议这种方式)。"},{"id":"ff5b5a69459c","tags":[{"text":"省去了If的判断","color":"#276F86","background":"#d6f0f8"},{"text":"每种状态都是一个方法","color":"#276F86","background":"#d6f0f8"}],"title":"2. 处理多个事件(Handling multiple events)","parent":"646cadfc4c07","children":[],"note":"在单个处理器(handler)中我们可以可以处理多个事件。此时,你应该针对不同事件实现IEventHandler。范例如下:\n public class ActivityWriter :\n      IEventHandler&lt;TaskCompletedEventData&gt;,\n      IEventHandler&lt;TaskCreatedEventData&gt;,\n      ITransientDependency\n   {\n      public void HandleEvent(TaskCompletedEventData eventData) {\n         //TODO: 处理事件\n      }\n      public void HandleEvent(TaskCreatedEventData eventData) {\n         //TODO: 处理事件\n      }\n   }"}],"note":"要进行事件的处理,你应该要实现IEventHandler接口如下所示:\n  public class ActivityWriter : IEventHandler&lt;TaskCompletedEventData&gt;, ITransientDependency {\n      public void HandleEvent(TaskCompletedEventData eventData) {\n         WriteActivity(&quot;A task is completed by id = &quot; + eventData.TaskId);\n      }\n   }\nEventBus已集成到依赖注入系统中。就如同我们在上例中实现ITransientDependency那样,当TaskCompleted事件触发,它会创建一个新的ActivityWriter类的实体并且调用它的HandleEvent方法,并接着释放它。详情请见依赖注入(DI)一文。"},{"id":"8ce5a13e607d","title":"注册处理器","parent":"935fc94ab6d3","children":[{"id":"087578e28164","tags":[{"text":"自动注册","color":"#276F86","background":"#d6f0f8"},{"text":"建议","color":"#276F86","background":"#d6f0f8"},{"text":"IEventHandler","color":"#276F86","background":"#d6f0f8"}],"title":"1. 自动型Automatically","parent":"8ce5a13e607d","children":[],"note":"ABP扫描所有实现IEventHandler接口的类,并且自动注册它们到事件总线中。当事件发生, 它通过依赖注入(DI)来取得处理器(handler)的引用对象并且在事件处理完毕之后将其释放。这是比较建议的事件总线使用方式于ABP中。"},{"id":"d8d0c549463f","tags":[{"text":"EventBus.Register","color":"#276F86","background":"#d6f0f8"},{"text":"IEventHandlerFactory","color":"#276F86","background":"#d6f0f8"}],"title":"2. 手动型(Manually)","parent":"8ce5a13e607d","children":[],"note":"也可以通过手动注册事件的方式,但是会有些问题。在Web应用程序中,事件的注册应该要在应用程序启动的时候。当一个Web请求(request)抵达时进行事件的注册,并且反复这个行为。这可能会导致你的应用程序发生一些问题,因为注册的类可以被调用多次。同样需要注意的是,手动注册无法与依赖注入系统一起使用。\nABP提供了多个事件总线注册方法的重载(overload)。最简单的一个重载方法是等待委派(delegate)或Lambda。\n  EventBus.Register&lt;TaskCompletedEventData&gt;(eventData =&gt;\n      {\n         WriteActivity(&quot;A task is completed by id = &quot; + eventData.TaskId);\n      });\n因此,事件:task completed会发生,而这个Lambda方法会被调用。第二个重载方法等待的是一个对象,该对象实现了IEventHandler:\nEventbus.Register&lt;TaskCompletedEventData&gt;(new ActivityWriter());\n相同的例子,如果ActivityWriter因事件而被调用。这个方法也有一个非泛型的重载。另一个重载接受两个泛化的参数:\nEventBus.Register&lt;TaskCompletedEventData, ActivityWriter&gt;();\n此时,事件总线创建一个新的ActivityWriter于每个事件。当它释放的时候,它会调用ActivityWriter.Dispose方法。\n最后,你可以注册一个事件处理器工厂(event handler factory)来负责创建处理器。处理器工厂有两个方法: GetHandler和ReleaseHandler,范例如下:\n  public class ActivityWriterFactory : IEventHandlerFactory {\n      public IEventHandler GetHandler() {\n         return new ActivityWriter();\n      }\n      public void ReleaseHandler(IEventHandler handler) {\n         //TODO: 释放ActivityWriter实体(处理器)\n      }\n   }\nABP也提供了特殊的工厂类,IocHandlerFactory,通过依赖注入系统，IocHandlerFactory可以用来创建或者释放(dispose)处理器。ABP可以自动化注册IocHandlerFactory。因此,如果你想要使用依赖注入系统,请直接使用自动化注册的方式。"}],"note":"我们必需注册处理器(handler)到事件总线中来处理事件。"},{"id":"4485c9fb3677","tags":[{"text":"Dispose()","color":"#276F86","background":"#d6f0f8"},{"text":"保存好对像的引用即可","color":"#276F86","background":"#d6f0f8"}],"title":"取消注册事件","parent":"935fc94ab6d3","children":[],"note":"当你手动注册事件总线,你或许想要在之后取消注册。最简单的取消事件注册的方式即为registration.Dispose()。举例如下:\n//注册一个事件\nVar registration = EventBus.Register&lt;TaskCompletedEventData&gt;(eventData =&gt; WriteActivity(&quot;A task is completed by id = &quot; + eventData.TaskId));\n//取消注册一个事件\nregistration.Dispose();\n当然,取消注册可以在任何地方任何时候进行。保存(keep)好注册的对象并且在你想要取消注册的时候释放(dispose)掉它。所有注册方法的重载(overload)都会返回一个可释放(disposable)的对象来取消事件的注册。\n事件总线也提供取消注册方法。使用范例:\n//创建一个处理器\nvar handler = new ActivityWriter();\n//注册一个事件\nEventBus.Register&lt;TaskCompletedEventData&gt;(handler);\n//取消这个事件的注册\nEventBus.Unregister&lt;TaskCompletedEventData&gt;(handler);\n它也提供重载的方法给取消注册的委派和工厂。取消注册处理器对象必须与之前注册的对象是同一个。\n最后,EventBus提供一个UnregisterAll()方法来取消某个事件所有处理器的注册,而UnregisterAll()方法则是所有事件的所有处理器。"}],"icons":[{"index":"61","text":"&#xe693","name":""}]}],"parent":"root"}]}},"meta":{"id":"5a584f55e4b0abe85d5109a4","member":"55506759e4b09739f462d50e","exportTime":"2018-01-15 13:14:24","diagramInfo":{"category":"mind_free","title":"ABP学习概念图","created":"2018-01-12 14:01:57","creator":"55506759e4b09739f462d50e","modified":"2018-01-15 13:14:01"},"type":"ProcessOn Schema File","version":"1.0"}}